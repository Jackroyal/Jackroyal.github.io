<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>搁浅St的blog</title>
  
  <subtitle>我最喜欢笨笨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bblove.me/"/>
  <updated>2018-07-08T11:40:28.000Z</updated>
  <id>https://bblove.me/</id>
  
  <author>
    <name>jackroyal</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>php学习笔记(3.6)--PHP中的引用</title>
    <link href="https://bblove.me/2018/07/08/php-learn-note-3-6/"/>
    <id>https://bblove.me/2018/07/08/php-learn-note-3-6/</id>
    <published>2018-07-08T09:40:28.000Z</published>
    <updated>2018-07-08T11:40:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近再看CI源码, 刚好有碰到引用相关问题, 索性又研究了下.</p><h1 id="1-什么是引用"><a href="#1-什么是引用" class="headerlink" title="1 什么是引用"></a>1 什么是引用</h1><p>引用,第一感觉就是想到C语言中的指针,两个变量指向同一个内存地址.但是php中的引用其实应该是别名, 可以类比的是linux系统中的硬链接,两个文件名实际指向同一个文件.</p><h1 id="2-引用传值"><a href="#2-引用传值" class="headerlink" title="2 引用传值"></a>2 引用传值</h1><p>我们在函数传参的时候可能会用到引用.在不同给的php版本中,写法也不同.</p><h2 id="2-1-例如-在php5-2中-我们可能用到以下写法"><a href="#2-1-例如-在php5-2中-我们可能用到以下写法" class="headerlink" title="2.1 例如,在php5.2中,我们可能用到以下写法."></a>2.1 例如,在php5.2中,我们可能用到以下写法.</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">($var)</span> </span>&#123;</span><br><span class="line">  $var++;</span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="number">0</span>;</span><br><span class="line">foo(&amp;$a);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'$a:'</span>.$a.<span class="string">"&lt;br&gt;"</span>;<span class="comment">//输出$a:1</span></span><br></pre></td></tr></table></figure><p>但是在php5.3+中就不推荐这种写法了5.3会报warning,在更高版本中,会报fatal错误<code>Call-time pass-by-reference has been removed</code>.</p><h2 id="2-2-推荐的写法是-在定义函数的时候如果是引用-在参数声明处直接标记为引用"><a href="#2-2-推荐的写法是-在定义函数的时候如果是引用-在参数声明处直接标记为引用" class="headerlink" title="2.2 推荐的写法是,在定义函数的时候如果是引用,在参数声明处直接标记为引用."></a>2.2 推荐的写法是,在定义函数的时候如果是引用,在参数声明处直接标记为引用.</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在定义函数时,直接声明参数为引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(&amp;$var)</span> </span>&#123;</span><br><span class="line">  $var++;</span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="number">0</span>;</span><br><span class="line">foo($a);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'$a:'</span>.$a.<span class="string">"&lt;br&gt;"</span>;<span class="comment">//输出$a:1</span></span><br></pre></td></tr></table></figure><h1 id="3-引用返回"><a href="#3-引用返回" class="headerlink" title="3 引用返回"></a>3 引用返回</h1><p>除了引用传值,还有一种常见的情况是引用返回.<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> &amp;<span class="title">foo</span><span class="params">(&amp;$var)</span> </span>&#123;</span><br><span class="line">  $var++;</span><br><span class="line">  <span class="keyword">return</span> $var;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="number">0</span>;</span><br><span class="line">$b=&amp;foo($a);</span><br><span class="line">$b=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'$a:'</span>.$a.<span class="string">"&lt;br&gt;"</span>;<span class="comment">//输出$a:4</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'$b:'</span>.$b.<span class="string">"&lt;br&gt;"</span>;<span class="comment">//输出$b:4</span></span><br></pre></td></tr></table></figure></p><p>此处需要注意的是,函数定义处需要显示声明<code>function &amp;foo</code>,在调用函数的时候也需要显示声明<code>$b=&amp;foo($a)</code>.这个跟上面讲到的引用传值不同.<br>那么如果我调用函数的时候如果不加<code>&amp;</code>调用,会怎么样呢?<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> &amp;<span class="title">foo</span><span class="params">(&amp;$var)</span> </span>&#123;</span><br><span class="line">  $var++;</span><br><span class="line">  <span class="keyword">return</span> $var;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="number">0</span>;</span><br><span class="line">$b=foo($a);</span><br><span class="line">$b=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'$a:'</span>.$a.<span class="string">"&lt;br&gt;"</span>;<span class="comment">//输出$a:1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'$b:'</span>.$b.<span class="string">"&lt;br&gt;"</span>;<span class="comment">//输出$b:4</span></span><br></pre></td></tr></table></figure></p><p>上面例子中的引用传值只是为了突显这种差别. 也可以用对象来表现这个差别.<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $value = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> &amp;<span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> foo;</span><br><span class="line"></span><br><span class="line">$myValue = &amp;$obj-&gt;getValue();</span><br><span class="line">$obj-&gt;value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> $myValue; <span class="comment">//输出2</span></span><br></pre></td></tr></table></figure></p><p>上面<code>public function &amp;getValue() {</code>或<code>$myValue = &amp;$obj-&gt;getValue();</code>中的<code>&amp;</code>,无论少了谁,都不是引用返回,会导致最后输出<code>$myValue=42</code></p><h1 id="4-对象的赋值和传值"><a href="#4-对象的赋值和传值" class="headerlink" title="4 对象的赋值和传值"></a>4 对象的赋值和传值</h1><p>在php5中,对象的赋值和参数传递并不是引用传递,实际传递的是对象标识符的拷贝.<br>上面已经讲到php中的引用其实是别名,对于对象而言,php5中对象变量并不直接指向对象内容,而是保存了一个对象标识符,通过标识符来访问对象的内容,在将对象变量赋值的时候,其实是将两个变量指向同一个标识符,下面看例子.<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $foo = <span class="number">1</span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> A;</span><br><span class="line">$b = $a;     <span class="comment">// $a ,$b都是同一个标识符的拷贝</span></span><br><span class="line">             <span class="comment">// ($a) = ($b) = &lt;id&gt;</span></span><br><span class="line"></span><br><span class="line">             $c = <span class="keyword">new</span> A;</span><br><span class="line">$d = &amp;$c;    <span class="comment">// $c ,$d是引用</span></span><br><span class="line">             <span class="comment">// ($c,$d) = &lt;id&gt;</span></span><br></pre></td></tr></table></figure></p><p>上面的例子比较清晰表明了2者的区别,总结下:<br>对于普通变量而言:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="number">1</span>;</span><br><span class="line">$b = &amp;$a;</span><br></pre></td></tr></table></figure></p><p>变量$a直接指向内容,当产生引用(即别名),那么<code>$a</code>和<code>$b</code>都指向同一个内容;<br>对于对象而言,中间隔着标识符:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="keyword">new</span> A;</span><br><span class="line">$b = &amp;$a;    <span class="comment">// $a ,$b是引用</span></span><br><span class="line">$c = $a;     <span class="comment">// $c和$a保存的是同一个标识符,保存在不同的地方</span></span><br></pre></td></tr></table></figure></p><p>通俗的讲,我们可以把标识符理解为门牌号,$a和$c中保存的是同样的门牌号,但是并不是记录在同一个地方,是相同内容的拷贝,他们都可以找到同一个人;而$a和$b只是别名的关系,它俩实际指向同一个,记录在同一个地方.</p><blockquote><p>$a的小本本记录门牌号A1234<br>$b的小本本(实际和$a是同一个小本本,彼此互为别名)记录门牌号A1234<br>$c的小本本记录门牌号A1234</p></blockquote><p>一图胜千言<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$b</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="literal">+</span>      </span><br><span class="line">              <span class="comment">|</span></span><br><span class="line"><span class="comment">$a</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="literal">+</span></span><br><span class="line">              <span class="comment">|</span>  </span><br><span class="line">              <span class="comment">v</span>   </span><br><span class="line">        <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>      </span><br><span class="line">        <span class="comment">|</span> <span class="comment">object</span> <span class="comment">id</span>   <span class="comment">|</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span> </span><br><span class="line">        <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>               <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>                                        <span class="comment">v</span></span><br><span class="line"><span class="comment"></span>        <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>      <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br><span class="line"><span class="comment">$c</span> <span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span> <span class="comment">object</span> <span class="comment">id</span>  <span class="comment">|</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">|</span> <span class="comment">object(Class</span> <span class="comment">A)</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>        <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>      <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></span><br></pre></td></tr></table></figure></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="http://php.net/manual/zh/language.references.pass.php" target="_blank" rel="noopener">php引用传递</a></li><li><a href="http://php.net/manual/zh/language.oop5.references.php" target="_blank" rel="noopener">对象和引用</a></li><li><a href="https://segmentfault.com/a/1190000002928594" target="_blank" rel="noopener">在PHP中对象真的是按引用传递的吗</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近再看CI源码, 刚好有碰到引用相关问题, 索性又研究了下.&lt;/p&gt;
&lt;h1 id=&quot;1-什么是引用&quot;&gt;&lt;a href=&quot;#1-什么是引用&quot; class=&quot;headerlink&quot; title=&quot;1 什么是引用&quot;&gt;&lt;/a&gt;1 什么是引用&lt;/h1&gt;&lt;p&gt;引用,第一感觉就是想到
      
    
    </summary>
    
      <category term="php学习笔记" scheme="https://bblove.me/categories/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="php" scheme="https://bblove.me/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>修复ubuntu终端中文显示和输入的问题</title>
    <link href="https://bblove.me/2017/04/24/repair-chinese-input-in-ubuntu/"/>
    <id>https://bblove.me/2017/04/24/repair-chinese-input-in-ubuntu/</id>
    <published>2017-04-24T05:37:01.000Z</published>
    <updated>2018-05-30T01:57:59.331Z</updated>
    
    <content type="html"><![CDATA[<p>我在管理服务器的时候,一般在win下面使用xshell和xftp两个软件,来进行管理和上传文件.不过一直有个头疼的问题:如果文件名是中文的,上传之后,在ftp软件中看到的是正常的,在xshell终端中看到的却是乱码;而且,在xshell中无法输入中文,所以我在vi中修改文件的时候一般只使用英文.</p><p>昨晚没事,就查了一下资料,修复了这个问题.</p><h1 id="1-目标"><a href="#1-目标" class="headerlink" title="1 目标"></a>1 目标</h1><p>本文的目标主要是修复中文文件名乱码和中文输入的问题,本文的目标不是把整个系统的所有语言体系都改成中文,只是单纯的修复中文输入问题和中文文件名显示问题.</p><h1 id="2-环境"><a href="#2-环境" class="headerlink" title="2 环境"></a>2 环境</h1><p><strong>服务器环境</strong>: Ubuntu Server 16.04 lts<br><strong>本地环境</strong>: windows7<br><strong>软件环境</strong>: Xshell 和 Xftp</p><h1 id="3-修改配置"><a href="#3-修改配置" class="headerlink" title="3 修改配置"></a>3 修改配置</h1><p>与中文编码相关的配置主要包括: 本地编码和服务器编码.我们首先设置服务器端编码:</p><h2 id="3-1-服务器编码配置"><a href="#3-1-服务器编码配置" class="headerlink" title="3.1 服务器编码配置"></a>3.1 服务器编码配置</h2><p>首先,我们使用xshell连接登录服务器,然后在终端中输入<code>locale</code>命令,得到结果如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ locale</span><br><span class="line">LANG=</span><br><span class="line">LANGUAGE=C:</span><br><span class="line">LC_CTYPE=<span class="string">"POSIX"</span></span><br><span class="line">LC_NUMERIC=<span class="string">"POSIX"</span></span><br><span class="line">LC_TIME=<span class="string">"POSIX"</span></span><br><span class="line">LC_COLLATE=<span class="string">"POSIX"</span></span><br><span class="line">LC_MONETARY=<span class="string">"POSIX"</span></span><br><span class="line">LC_MESSAGES=<span class="string">"POSIX"</span></span><br><span class="line">LC_PAPER=<span class="string">"POSIX"</span></span><br><span class="line">LC_NAME=<span class="string">"POSIX"</span></span><br><span class="line">LC_ADDRESS=<span class="string">"POSIX"</span></span><br><span class="line">LC_TELEPHONE=<span class="string">"POSIX"</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">"POSIX"</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">"POSIX"</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure></p><p>各个选项的含义如下:</p><ul><li>语言符号及其分类(LC_CTYPE)</li><li>数字(LC_NUMERIC)</li><li>比较和排序习惯(LC_COLLATE)</li><li>时间显示格式(LC_TIME)</li><li>货币单位(LC_MONETARY)</li><li>信息主要是提示信息,错误信息, 状态信息, 标题, 标签, 按钮和菜单等(LC_MESSAGES)</li><li>姓名书写方式(LC_NAME)</li><li>地址书写方式(LC_ADDRESS)</li><li>电话号码书写方式(LC_TELEPHONE)</li><li>度量衡表达方式(LC_MEASUREMENT)</li><li>默认纸张尺寸大小(LC_PAPER)</li><li>对locale自身包含信息的概述(LC_IDENTIFICATION)。</li></ul><p>关于<code>locale</code>更多的信息,请查看<a href="http://wiki.ubuntu.org.cn/Locale" target="_blank" rel="noopener">Locale-wiki</a><br>我们要修复的是中文文件名的显示和中文输入的问题,所以我们接下来只需要设置<code>LC_CTYPE</code>即可.</p><p>查看系统支持的编码方式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale -a</span><br></pre></td></tr></table></figure></p><p>看看输出内容中是否包含<code>zh_CN.utf-8</code>,如果不包含的话,我们需要添加这个配置项<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo locale-gen zh_CN.utf-8</span><br></pre></td></tr></table></figure></p><p>修改后,我的输出内容如下,已经包含<code>zh_CN.utf-8</code><br><img src="https://ws1.sinaimg.cn/large/692869a3gy1fexql3wkdej2076047744.jpg" alt="查看系统支持的编码方式"><br>接下来,修改<code>LC_CTYPE</code>的值,使用<code>export LC_CTYPE=&#39;zh_CN.UTF-8&#39;</code>,命令来修改.<br>直接执行<code>export LC_CTYPE=&#39;zh_CN.UTF-8&#39;</code>那么只对当前会话有效,<br><strong>所有用户(永久)</strong>:修改/etc/profile<br><strong>当前用户(永久)</strong>:修改~/.bashrc</p><p>建议直接修改<code>/etc/profile</code>文件,这样所有用户都可以使用.<br>修改完成后,退出登录,重新登录一次,再输入<code>locale</code>命令,可以得到如下输出:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LANG=</span><br><span class="line">LANGUAGE=C:</span><br><span class="line">LC_CTYPE=zh_CN.UTF-8</span><br><span class="line">LC_NUMERIC=<span class="string">"POSIX"</span></span><br><span class="line">LC_TIME=<span class="string">"POSIX"</span></span><br><span class="line">LC_COLLATE=<span class="string">"POSIX"</span></span><br><span class="line">LC_MONETARY=<span class="string">"POSIX"</span></span><br><span class="line">LC_MESSAGES=<span class="string">"POSIX"</span></span><br><span class="line">LC_PAPER=<span class="string">"POSIX"</span></span><br><span class="line">LC_NAME=<span class="string">"POSIX"</span></span><br><span class="line">LC_ADDRESS=<span class="string">"POSIX"</span></span><br><span class="line">LC_TELEPHONE=<span class="string">"POSIX"</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">"POSIX"</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">"POSIX"</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure></p><p>应该就可以输入中文了</p><h2 id="3-2-本地配置"><a href="#3-2-本地配置" class="headerlink" title="3.2 本地配置"></a>3.2 本地配置</h2><p>在windows中,中文的默认编码是GBK,所以为了避免出现在ftp中看着正常,在xshell中看着乱码的问题.我们要修改xftp中的编码方式.打开xftp,文件-&gt;属性-&gt;选项,勾选上<code>使用UTF-8编码</code>.<br><img src="https://ws1.sinaimg.cn/large/692869a3gy1fexreyc5kyj20c007wt8w.jpg" alt="修改xftp编码方式"></p><h2 id="3-3-编码转换"><a href="#3-3-编码转换" class="headerlink" title="3.3 编码转换"></a>3.3 编码转换</h2><p>上面的修改完成后,基本可以解决之前提到的目标.新上传的文件肯定是正常的,但是之前上传的文件依旧是乱码,所以我们需要使用工具转换一下.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install convmv</span><br></pre></td></tr></table></figure></p><p>用法很简单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convmv -f GBK -t UTF-8 --notest ./*</span><br></pre></td></tr></table></figure></p><p>其中,<code>-f</code>表示源编码;<code>-t</code>表示目标编码;如果没有<code>--notest</code>选项,这条命令只会检测,不会执行;后面跟着需要操作的文件目录;如果需要递归执行,可以加上<code>-r</code>选项.</p><p>打完收工</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="http://wiki.ubuntu.org.cn/Locale" target="_blank" rel="noopener">Locale-wiki</a></li><li><a href="https://segmentfault.com/q/1010000000150673" target="_blank" rel="noopener">MacOS用iTerm连接到Linux上，不能输入中文</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我在管理服务器的时候,一般在win下面使用xshell和xftp两个软件,来进行管理和上传文件.不过一直有个头疼的问题:如果文件名是中文的,上传之后,在ftp软件中看到的是正常的,在xshell终端中看到的却是乱码;而且,在xshell中无法输入中文,所以我在vi中修改文件
      
    
    </summary>
    
      <category term="Linux" scheme="https://bblove.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://bblove.me/tags/Linux/"/>
    
      <category term="ubuntu" scheme="https://bblove.me/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>将hexo部署到自己的个人服务器上</title>
    <link href="https://bblove.me/2017/04/08/deploy-hexo-in-my-own-vps/"/>
    <id>https://bblove.me/2017/04/08/deploy-hexo-in-my-own-vps/</id>
    <published>2017-04-08T11:22:22.000Z</published>
    <updated>2018-05-30T01:57:59.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文假设你已经配置好了hexo了,这是前提</p></blockquote><p>前面两篇文章主要是用来配置自己的服务器.服务器部署完成后,后面就可以开始写博客了.但是每次<code>hexo d</code>推送到gihub的服务器上了,还需要手动将文件复制到自己的服务器对应网站的根目录,对的,要手动,当然不能忍.</p><h1 id="1-ugly的解决办法"><a href="#1-ugly的解决办法" class="headerlink" title="1 ugly的解决办法"></a>1 ugly的解决办法</h1><p>于是我写了一个脚本,在服务器上定时去访问我的github,如果检测到文件有变动,就把github的内容clone到服务器上,然后再布置到网站根目录.<br>代码很简单,就这几行.主要是检测<code>/archives/index.html</code>这个文件的大小是否变化了,选择它,是由于这个文件较小,而且每次发布新文章大小都会发生变化.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">cd</span> ~/blogsync</span><br><span class="line">length=`ls -l github.json| awk <span class="string">'&#123;print $5&#125;'</span>`</span><br><span class="line">curl -o github.json  https://raw.githubusercontent.com/huirong/huirong.github.io/master/archives/index.html</span><br><span class="line">newlength=`ls -l github.json| awk <span class="string">'&#123;print $5&#125;'</span>`</span><br><span class="line"><span class="built_in">test</span> <span class="variable">$length</span> -eq <span class="variable">$newlength</span> &amp;&amp; <span class="built_in">exit</span> 0 <span class="comment">#if same so quit</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/huirong/huirong.github.io.git huirongis_me</span><br><span class="line">rm -fr ~/www/huirongis_me</span><br><span class="line">mv huirongis_me ~/www/</span><br></pre></td></tr></table></figure></p><p>这样搞法,是不需要手动了,但是做不到实时,而且,如果你没有新增或删减文章,其他的改动,可能不会反应在<code>/archives/index.html</code>,那他就不会自动去更新了.</p><h1 id="2-完美的搞法"><a href="#2-完美的搞法" class="headerlink" title="2 完美的搞法"></a>2 完美的搞法</h1><p>既然有ugly的解决方法,自然有完美的解决方法.本文主要是参考 <a href="http://www.swiftyper.com/2016/04/17/deploy-hexo-with-git-hook/" target="_blank" rel="noopener">使用 Git Hook 自动部署 Hexo 到个人 VPS</a>.<br>这个方法的原理,用一句话总结就是:<strong>在自己的服务器上搭建一个git服务器,然后依靠<code>git hook</code>程序,将git仓库代码更新到自己的网站根目录</strong>.</p><h2 id="2-1-在vps上安装git"><a href="#2-1-在vps上安装git" class="headerlink" title="2.1 在vps上安装git"></a>2.1 在vps上安装git</h2><p>我的服务器是ubuntu 16.04 lts,安装git服务非常简单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p><h2 id="2-2-创建git用户"><a href="#2-2-创建git用户" class="headerlink" title="2.2 创建git用户"></a>2.2 创建git用户</h2><p>这一步的原因是,我们需要一个小权限的账号来操作git.比如我们后面会限制这个git账号,不让他登录shell等等.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser git</span><br></pre></td></tr></table></figure></p><p>我们在<strong>服务器</strong>的ubuntu执行这条命令就好了,非常简单,而且还帮你在<code>home</code>下建立了对应的目录.<br>接下来要配置<code>git</code>用户的认证,有两种办法:</p><ul><li>给<code>git</code>用户设置一个密码,以后每次执行<code>hexo d</code>的时候,会要求你输入密码,才能继续操作</li><li>给<code>git</code>用户配置ssh证书,当把公钥传到服务器后,每次<code>hexo d</code>免密,直接操作完成</li></ul><h2 id="2-3-设置密码登录"><a href="#2-3-设置密码登录" class="headerlink" title="2.3 设置密码登录"></a>2.3 设置密码登录</h2><p>设置密码使用Linux命令<code>passwd</code>即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure></p><p>上述命令执行完成后,按照提示输入两次密码,即配置完成</p><h2 id="2-4-配置ssh证书"><a href="#2-4-配置ssh证书" class="headerlink" title="2.4 配置ssh证书"></a>2.4 配置ssh证书</h2><p>配置ssh证书,设置的时候比较麻烦,但是后面每次使用比较简单.后面再说原因.</p><h3 id="2-4-1-生成ssh证书"><a href="#2-4-1-生成ssh证书" class="headerlink" title="2.4.1 生成ssh证书"></a>2.4.1 生成ssh证书</h3><p>首先,我们需要生成证书,这一步我们在自己本地电脑进行.<strong>注意</strong>:生成证书不在服务器上操作,在自己<strong>本地电脑</strong>上进行.</p><p><strong>Mac或者Linux</strong><br>对于Mac或者LInux用户,直接使用系统自带的终端就好<br><strong>windows</strong>:<br>对于windows用户,hexo配置完成后,你应该有一个执行shell命令的软件,比如我的是github desktop自带的shell程序,或者你自己安装的git shell,也是可以的,大概长这样<br><img src="https://ws1.sinaimg.cn/large/692869a3gy1fefka44bdmj20gj094glp.jpg" alt="git shell程序界面"></p><p>首先,我们打开shell程序,输入以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"你的email地址"</span></span><br></pre></td></tr></table></figure></p><p>接着提示让我们输入文件保存的路径,如果你不输入就按照默认的保存,输入完成,回车<br>下一步,提示我们输入密码,这个密码只是证书的密码,即,当使用这个证书登录的时候要输入的密码,它不是服务器用户的密码,而是单纯给ssh证书设置的密码.<br>我这里选择不设置,直接回车,提示确认起码,再回车<br><img src="https://ws1.sinaimg.cn/large/692869a3gy1fefkzl7f04j20eq07wq34.jpg" alt="生成证书"><br>证书生成完毕.<br>我们进入刚才证书保存的目录,可以看到<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件(也有可能是其他名字,反正一个有pub一个没pub),分别就是私钥和公钥.</p><p><strong>PS</strong>:其实生成证书这一步,在服务器上,或者任何一个机器上都可以,只要你最后把这个公钥传到服务器,用这个私钥链接你的服务器就行,这里为求简单,在本地的git shell中生成</p><h3 id="2-4-2-上传公钥"><a href="#2-4-2-上传公钥" class="headerlink" title="2.4.2 上传公钥"></a>2.4.2 上传公钥</h3><p>接下来,我们还是在<strong>本地终端</strong>操作.将上一步生成的<code>id_rsa.pub</code>文件内容追加到服务器的<code>authorized_keys</code>中.<br>OpenSSH提供了一个命令<code>ssh-copy-id</code>,直接将文件添加到服务器,简直不能更方便<br>用法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id git@yourserver</span><br></pre></td></tr></table></figure></p><p>比如我输入<code>ssh-copy-id -i ~/.ssh/id_rsa.pub git@bblove.me</code>,这里的yourserver可以输入域名或者ip,<code>-i</code>用来指定具体的公钥文件,适用于存在多个公钥或者找不到公钥的情况,最好手动指定它.输入该命令后,会要求你输入服务器上<code>git</code>用户的密码.</p><p><img src="https://ws1.sinaimg.cn/large/692869a3gy1feflmcy70yj20g5070ab1.jpg" alt="authorized_keys文件内容"></p><p>如果此法不通,你可以直接在服务器上编辑<code>authorized_keys</code>文件,把<code>id_rsa.pub</code>内容追加到文件后面即可<br>请务必确认<code>authorized_keys</code>文件的权限是<code>rw-------</code>,如果不是,使用<code>chmod 600 authorized_keys</code>来修改.</p><h3 id="2-4-3-测试ssh连接"><a href="#2-4-3-测试ssh连接" class="headerlink" title="2.4.3 测试ssh连接"></a>2.4.3 测试ssh连接</h3><p>接下来,我们还是在<strong>本地终端</strong>操作.我们测试一下,看是否能成功连接到服务器.主要使用<code>ssh -T git@yourserver</code>命令来测试,此处<code>git</code>是指用户名,<code>yourserver</code>填你的服务器域名或者ip即可.测试结果如下:<br><img src="https://ws1.sinaimg.cn/large/692869a3gy1fek9m0bm0wj20fs0573yk.jpg" alt="个人vps的ssh测试结果"></p><p>如果测试不成功,他会返回给你错误提示.如果像我上图这样,那就是测试成功了,需要手动<code>ctr+c</code>,让git终端回复到正常输入命令的状态.下面附上github的测试结果,与我的vps略有不同,反正都是成功的.<br><img src="https://ws1.sinaimg.cn/large/692869a3gy1fek9nadydfj20g102adfr.jpg" alt="github的测试结果"></p><h3 id="2-4-4-ssh测试失败"><a href="#2-4-4-ssh测试失败" class="headerlink" title="2.4.4 ssh测试失败"></a>2.4.4 ssh测试失败</h3><p>如果你测试失败,可能有多方面的原因,客户端或者服务器都有可能.</p><h4 id="2-4-4-1-客户端ssh配置"><a href="#2-4-4-1-客户端ssh配置" class="headerlink" title="2.4.4.1 客户端ssh配置"></a>2.4.4.1 客户端ssh配置</h4><p>接下来,还是在<strong>本地终端</strong>操作.我们首先检查一下客户端ssh的配置,文件的位置在<code>/etc/ssh/ssh_config</code>,我们使用<code>vi /etc/ssh/ssh_config</code>命令打开和编辑该文件.本文服务器域名是<code>bblove.me</code>,请检查你的<code>ssh_config</code>文件,是否存在一条<code>Host *</code>记录,并且该记录的<code>IdentityFile</code>值,是否是你刚才生成的那个私钥的地址.<br>这个配置文件的意思是,针对某个<code>Host</code>,程序使用<code>IdentityFile</code>指定的私钥文件去进行ssh连接.<br>如果我们上一步测试ssh连接失败,有可能就是针对我们自己的域名,我们未指定正确的私钥文件.附上我的<code>ssh_config</code>文件的内容,<br><img src="https://ws1.sinaimg.cn/large/692869a3gy1fefmq9g0tsj20gj094aad.jpg" alt="修改ssh_config文件"></p><p>这也就意味着,我们可以针对多个网站各自配置不同的ssh证书,比如我github一套,自己服务器一套.当然偷懒的话,也可以所有网站使用一套ssh证书.只需要添加配置<code>Host *</code>的配置即可.你的配置文件内容可能和我的不同,关注下<code>host</code>和<code>IdentityFile</code>的内容就好.<br><img src="https://ws1.sinaimg.cn/large/692869a3gy1fefmtf7x24j20ie0kxjsn.jpg" alt="ubuntu中ssh_config文件"><br><strong>PS</strong>:如果host配置了<code>*</code>,请务必保证它在其他域名配置的后面,因为系统是从前到后匹配,所以<code>*</code>必须在具体域名的后面.</p><h4 id="2-4-4-2-服务器ssh配置"><a href="#2-4-4-2-服务器ssh配置" class="headerlink" title="2.4.4.2 服务器ssh配置"></a>2.4.4.2 服务器ssh配置</h4><p>接下来,我们在<strong>服务器</strong>上操作.我们检查一下服务器端ssh配置是否有误.文件的位置在<code>/etc/ssh/sshd_config</code>,我们使用<code>sudo vi /etc/ssh/sshd_config</code>打开和编辑该文件.例如我的ubuntu虚拟机的内容经过修改后,就是这样的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Package generated configuration file</span></span><br><span class="line"><span class="comment"># See the sshd_config(5) manpage for details</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># What ports, IPs and protocols we listen for</span></span><br><span class="line"><span class="comment">#这个是用来指定ssh端口的,不用改</span></span><br><span class="line">Port 22</span><br><span class="line"><span class="comment"># Use these options to restrict which interfaces/protocols sshd will bind to</span></span><br><span class="line"><span class="comment">#ListenAddress 10.105.224.192</span></span><br><span class="line"><span class="comment">#ListenAddress 10.105.224.192</span></span><br><span class="line">Protocol 2</span><br><span class="line"><span class="comment"># HostKeys for protocol version 2</span></span><br><span class="line">HostKey /etc/ssh/ssh_host_rsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_dsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ed25519_key</span><br><span class="line"><span class="comment">#Privilege Separation is turned on for security</span></span><br><span class="line">UsePrivilegeSeparation yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Lifetime and size of ephemeral version 1 server key</span></span><br><span class="line">KeyRegenerationInterval 3600</span><br><span class="line">ServerKeyBits 1024</span><br><span class="line"></span><br><span class="line"><span class="comment"># Logging</span></span><br><span class="line">SyslogFacility AUTH</span><br><span class="line">LogLevel INFO</span><br><span class="line"></span><br><span class="line"><span class="comment"># Authentication:</span></span><br><span class="line">LoginGraceTime 120</span><br><span class="line">PermitRootLogin no</span><br><span class="line">StrictModes yes</span><br><span class="line"></span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile%h/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Don't read the user's ~/.rhosts and ~/.shosts files</span></span><br><span class="line">IgnoreRhosts yes</span><br><span class="line"><span class="comment"># For this to work you will also need host keys in /etc/ssh_known_hosts</span></span><br><span class="line">RhostsRSAAuthentication no</span><br><span class="line"><span class="comment"># similar for protocol version 2</span></span><br><span class="line">HostbasedAuthentication no</span><br><span class="line"><span class="comment"># Uncomment if you don't trust ~/.ssh/known_hosts for RhostsRSAAuthentication</span></span><br><span class="line"><span class="comment">#IgnoreUserKnownHosts yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To enable empty passwords, change to yes (NOT RECOMMENDED)</span></span><br><span class="line">PermitEmptyPasswords no</span><br><span class="line"></span><br><span class="line"><span class="comment"># Change to yes to enable challenge-response passwords (beware issues with</span></span><br><span class="line"><span class="comment"># some PAM modules and threads)</span></span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line"></span><br><span class="line"><span class="comment"># Change to no to disable tunnelled clear text passwords</span></span><br><span class="line">PasswordAuthentication yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Kerberos options</span></span><br><span class="line"><span class="comment">#KerberosAuthentication no</span></span><br><span class="line"><span class="comment">#KerberosGetAFSToken no</span></span><br><span class="line"><span class="comment">#KerberosOrLocalPasswd yes</span></span><br><span class="line"><span class="comment">#KerberosTicketCleanup yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GSSAPI options</span></span><br><span class="line"><span class="comment">#GSSAPIAuthentication no</span></span><br><span class="line"><span class="comment">#GSSAPICleanupCredentials yes</span></span><br><span class="line"></span><br><span class="line">X11Forwarding yes</span><br><span class="line">X11DisplayOffset 10</span><br><span class="line">PrintMotd no</span><br><span class="line">PrintLastLog yes</span><br><span class="line">TCPKeepAlive yes</span><br><span class="line"><span class="comment">#UseLogin no</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#MaxStartups 10:30:60</span></span><br><span class="line"><span class="comment">#Banner /etc/issue.net</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Allow client to pass locale environment variables</span></span><br><span class="line">AcceptEnv LANG LC_*</span><br><span class="line">AllowUsers chen git zhou</span><br><span class="line">Subsystem sftp /usr/lib/openssh/sftp-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set this to 'yes' to enable PAM authentication, account processing,</span></span><br><span class="line"><span class="comment"># and session processing. If this is enabled, PAM authentication will</span></span><br><span class="line"><span class="comment"># be allowed through the ChallengeResponseAuthentication and</span></span><br><span class="line"><span class="comment"># PasswordAuthentication.  Depending on your PAM configuration,</span></span><br><span class="line"><span class="comment"># PAM authentication via ChallengeResponseAuthentication may bypass</span></span><br><span class="line"><span class="comment"># the setting of "PermitRootLogin without-password".</span></span><br><span class="line"><span class="comment"># If you just want the PAM account and session checks to run without</span></span><br><span class="line"><span class="comment"># PAM authentication, then enable this but set PasswordAuthentication</span></span><br><span class="line"><span class="comment"># and ChallengeResponseAuthentication to 'no'.</span></span><br><span class="line">UsePAM yes</span><br><span class="line">Ciphers aes128-cbc,aes192-cbc,aes256-cbc,aes128-ctr,aes192-ctr,aes256-ctr,3des-cbc,arcfour128,arcfour256,arcfour,blowfish-cbc,cast128-cbc</span><br><span class="line">MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,hmac-sha1-96,hmac-md5-96</span><br><span class="line">KexAlgorithms diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1,diffie-hellman-group-exchange-sha256,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group1-sha1,curve25519-sha256@libssh.org</span><br><span class="line">UseDNS no</span><br></pre></td></tr></table></figure></p><p>我们只需要重点关注下这几个值,</p><ul><li><code>PermitRootLogin no</code>,也就是不允许使用root登录,这是为了安全起见</li><li><code>AuthorizedKeysFile    %h/.ssh/authorized_keys</code>,指定公钥存放的文件,这个要重点关注下,注意去掉前面的注释</li></ul><p>其他的配置,基本不用修改.以上配置修改完成后,我们重启一下服务器端的ssh服务,使用命令<code>sudo service ssh restart</code>即可.最后,我们再回到<strong>客户端</strong>,测试一下ssh连接是否成功.<code>ssh -T git@yourserver</code>.还不行的话,你就去google查一查错误</p><h2 id="2-5-配置服务器git仓库"><a href="#2-5-配置服务器git仓库" class="headerlink" title="2.5 配置服务器git仓库"></a>2.5 配置服务器git仓库</h2><p>上一步,我们配置好了客户端ssh连服务器,这一步我们回到<strong>服务器</strong>上去操作.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在服务器新建一个文件夹,用来存放git仓库</span></span><br><span class="line">sudo mkdir /home/chen/bblove</span><br><span class="line"><span class="built_in">cd</span> /home/chen/bblove</span><br><span class="line"><span class="comment">#进入文件夹,对git仓库进行初始化</span></span><br><span class="line">sudo git init --bare blog.git</span><br><span class="line"><span class="comment">#初始化完成后,进入hooks文件夹</span></span><br><span class="line"><span class="built_in">cd</span> /home/chen/bblove/blog.git/hooks</span><br><span class="line"><span class="comment">#新建一个钩子程序,这个文件名可以自定义,我取名为post-receive</span></span><br><span class="line">vi post-receive</span><br></pre></td></tr></table></figure></p><p>我们在post-receive中,写入如下代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">git --work-tree=/home/chen/www/bblove_me --git-dir=/home/chen/bblove/blog.git checkout -f</span><br></pre></td></tr></table></figure></p><p>此处,<code>--work-tree</code>指的是你的网站根目录,<code>--git-dir</code>指的是你的git仓库的目录.<br>编辑完城后,<code>wq</code>退出并保存<code>post-receive</code>文件.下面给钩子程序加上可执行权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给钩子程序加上可执行权限</span></span><br><span class="line">sudo chmod +x /home/chen/bblove/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure></p><p>最后,修改git仓库权限,否则客户端无法提交代码到这个仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#接下来修改git仓库的权限</span></span><br><span class="line">sudo chown -R git:git blog.git</span><br></pre></td></tr></table></figure></p><p>此处还要注意一点,我们还要修改网站根目录的权限,否则钩子程序执行的时候,无法修改网站根目录的内容.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R git:git /home/chen/www/bblove_me</span><br></pre></td></tr></table></figure></p><p>至此,服务器端配置完成</p><h2 id="2-6-修改hexo的配置文件"><a href="#2-6-修改hexo的配置文件" class="headerlink" title="2.6 修改hexo的配置文件"></a>2.6 修改hexo的配置文件</h2><p>终于,走到了这一步.<br>我们打开我们自己hexo博客根目录的<code>_config.yml</code>文件.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- <span class="built_in">type</span>: git</span><br><span class="line">  repo: <span class="string">'https://github.com/Jackroyal/Jackroyal.github.io.git'</span></span><br><span class="line">  branch: master</span><br><span class="line">- <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@bblove.me:/home/git/bblove/blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>因为,hexo本身是支持多点发布的,所以我们每次deploy的时候,让他同时推到github和自己的服务器上去.<br>你只需要改<code>repo: git@bblove.me:/home/git/bblove/blog.git</code>这一行,<code>git@yourserver:/your-git-dir</code>.<br>ok,大功告成啦,赶快<code>hexo d -g</code>看看效果吧</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="http://www.swiftyper.com/2016/04/17/deploy-hexo-with-git-hook/" target="_blank" rel="noopener">使用 Git Hook 自动部署 Hexo 到个人 VPS</a></li><li><a href="http://blog.csdn.net/linghe301/article/details/8211305#" target="_blank" rel="noopener">Linux启动或禁止SSH用户及IP的登录</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文假设你已经配置好了hexo了,这是前提&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面两篇文章主要是用来配置自己的服务器.服务器部署完成后,后面就可以开始写博客了.但是每次&lt;code&gt;hexo d&lt;/code&gt;推送到gihub的服务器上了,还需
      
    
    </summary>
    
      <category term="Hexo" scheme="https://bblove.me/categories/Hexo/"/>
    
    
      <category term="Linux" scheme="https://bblove.me/tags/Linux/"/>
    
      <category term="hexo" scheme="https://bblove.me/tags/hexo/"/>
    
      <category term="Nginx" scheme="https://bblove.me/tags/Nginx/"/>
    
      <category term="ubuntu" scheme="https://bblove.me/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Nginx上多站点的https配置</title>
    <link href="https://bblove.me/2017/04/05/nginx-https-setting-on-multiple-sites/"/>
    <id>https://bblove.me/2017/04/05/nginx-https-setting-on-multiple-sites/</id>
    <published>2017-04-05T05:09:24.000Z</published>
    <updated>2018-05-30T01:57:59.320Z</updated>
    
    <content type="html"><![CDATA[<p><strong>更新</strong></p><ul><li>2017-06-13 修改证书生成目录,为方便后续的git push自动更新,将acme验证目录移出网站根目录</li></ul><p>此处接上篇<a href="https://bblove.me/2017/04/05/nginx-installation-and-setting-in-ubuntu-server">在ubuntu上安装和配置Nginx</a>,本文在之前的基础上配置https.</p><h1 id="1-环境和目标"><a href="#1-环境和目标" class="headerlink" title="1 环境和目标"></a>1 环境和目标</h1><p>服务器:ubuntu server 16.04.2 LTS<br>主要工具:xshell<br>本文的目标是使用Nginx的TLS SNI技术,使用一个服务器(即一个ip),给多个域名配置https.我有一个腾讯云服务器,买了两个域名,都指向这台服务器,我现在想两个域名都上https,而且<code>www.bblove.me</code>跳转到<code>bblove.me</code>,我只想使用<code>bblove.me</code>这个较短的域名.<br>但是不是所有的浏览器都支持SNI,下面的截图来自屈大的博客<br><img src="https://ws1.sinaimg.cn/large/692869a3gy1febqcpfjoaj20kv08mjrs.jpg" alt="SNI支持情况"><br>由于是个人博客,随意折腾,所以不犹豫,直接上https.</p><h1 id="2-证书"><a href="#2-证书" class="headerlink" title="2 证书"></a>2 证书</h1><p>我们使用Let’s Encrypt提供的免费证书,每次有90天的有效期,过期之后需要再更新,不过这对于程序员来说,根本就不是事儿对吧.点击<a href="https://github.com/Neilpang/acme.sh" target="_blank" rel="noopener">ACME</a>,我们使用ACME来自动获取证书.主要步骤分三步:</p><ul><li>安装 acme.sh</li><li>生成证书</li><li>copy 证书到 nginx<br>具体步骤,参考github上的wiki  <a href="https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">ACME使用说明</a><br>下面我简单说下我这边的配置:<h2 id="2-1-安装acme-sh"><a href="#2-1-安装acme-sh" class="headerlink" title="2.1 安装acme.sh"></a>2.1 安装acme.sh</h2>安装的命令很简单<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl  https://get.acme.sh | sh</span><br></pre></td></tr></table></figure></li></ul><p>建议将脚本放在自己的home目录下,并且建立一个alias<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh=~/.acme.sh/acme.sh</span><br></pre></td></tr></table></figure></p><p>操作的目录都只会在<code>~/acme.sh</code>目录,不会污染系统其他的文件夹和目录</p><h2 id="2-2-生成证书"><a href="#2-2-生成证书" class="headerlink" title="2.2 生成证书"></a>2.2 生成证书</h2><p>脚本安装好后,下一步开始生成证书,生成证书的过程中,Let’s Encrypt需要对域名的所有权进行验证,这个很好理解,证书发行机构需要确定你是否对该域名拥有所有权.验证的方式有两种:</p><ul><li>使用http验证<br>acme脚本会生成一个验证文件,并放到网站根目录,然后Let’s Encrypt会尝试访问这个文件,完成验证</li><li>使用DNS验证<br>顾名思义,只需要在DNS设置中添加一条txt解析记录,即可</li></ul><p>本文采用的是http验证,DNS验证就不细说了,想使用DNS验证的直接看 <a href="https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">ACME使用说明</a></p><p>我一共有两个域名<code>bblove.me</code>和<code>huirongis.me</code>,主域名加上带<code>www</code>的子域名,也就是一共有4个域名.<br>生成证书有下面三种思路:</p><ul><li>所有的4个域名都使用同一个证书,此法最简单,可以避免发生域名和证书不匹配的情况</li><li><code>www.bblove.me</code>和<code>bblove.me</code>使用同一个证书,另外一个域名同理,也就是总共使用两个证书</li><li>使用4个不同的证书,这种情况比较复杂,如果想实现<code>www</code>跳转到不带<code>www</code>的,处理不好容易出现证书错误的问题</li></ul><p>由于我最后只使用<code>https://bblove.me</code>这个域名,验证方式选择的http方式,<code>bblove.me</code>和<code>huirongis.me</code>指向不同的根目录,为了方便后续管理和维护,所以我选择方案二,即<code>bblove.me</code>和<code>www.bblove.me</code>共用一个证书,<code>huirongis.me</code>同理.<br>确定好方案后,下面开始生成证书,使用如下命令即可.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --issue -d bblove.me -d www.bblove.me -w /home/chen/www/nginx_acme/bblove_me/ --force</span><br></pre></td></tr></table></figure></p><p>其中<code>-d</code>表示域名,可以添加多个;<code>-w</code>表示网站的根目录,一条命令执行完成,即可得到证书.<br>顺利的话,执行结果如下(此处配图输入命令未更新,输出结果是一致的):<br><img src="https://ws1.sinaimg.cn/large/692869a3gy1fecw65xpvrj20lv0ll0vo.jpg" alt="生成证书"><br>如果出错的话,在那条命令后面追加<code>--debug</code>,查看详细的信息,我有遇到过文件权限的错误,只要网站根目录权限和当前home目录对应的用户权限一样就可以了;我还遇到过验证不通过的问题,大家可以在浏览器中访问那个路径,看是否正常,类似<code>http://bblove.me/.well-known/acme-challenge/dfdfdfdafdfdfdfdfdfdfdfd</code>这样的格式</p><h2 id="2-3-安装证书"><a href="#2-3-安装证书" class="headerlink" title="2.3 安装证书"></a>2.3 安装证书</h2><p>在上一步中,我们已经成功的生成了我们要的证书.这一步我们将它安装在我们域名所对应的根目录中,操作很简单.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --installcert -d bblove.me --keypath /home/chen/www/nginx_ssl/bblove_me/bblove_me.key --fullchainpath /home/chen/www/nginx_ssl/bblove_me/bblove_me.cer --reloadcmd <span class="string">"service nginx force-reload"</span></span><br></pre></td></tr></table></figure></p><p>执行结果如图所示:<br><img src="https://ws1.sinaimg.cn/large/692869a3gy1fecwexr6nej20g606gaaf.jpg" alt="安装证书"><br>至此,证书部分已经操作完成,第二个域名操作同理.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成证书</span></span><br><span class="line">acme.sh --issue -d bblove.me -d www.bblove.me -w /home/chen/www/nginx_acme/bblove_me/ --force</span><br><span class="line"><span class="comment">#安装证书</span></span><br><span class="line">acme.sh --installcert -d bblove.me --keypath /home/chen/www/nginx_ssl/bblove_me/bblove_me.key --fullchainpath /home/chen/www/nginx_ssl/bblove_me/bblove_me.cer --reloadcmd <span class="string">"service nginx force-reload"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成证书</span></span><br><span class="line">acme.sh --issue -d huirongis.me -d www.huirongis.me -w /home/chen/www/huirongis_me/ --force</span><br><span class="line"><span class="comment">#安装证书</span></span><br><span class="line">acme.sh --installcert -d huirongis.me --keypath /home/chen/www/nginx_ssl/huirongis_me/huirongis_me.key --fullchainpath /home/chen/www/nginx_ssl/huirongis_me/huirongis_me.cer --reloadcmd <span class="string">"service nginx force-reload"</span></span><br></pre></td></tr></table></figure></p><h1 id="3-修改Nginx配置"><a href="#3-修改Nginx配置" class="headerlink" title="3 修改Nginx配置"></a>3 修改Nginx配置</h1><p>证书生成完成后,我们需要修改Nginx配置,主要就是启用之前注释掉的HTTPS相关的配置以及,修改对应的目录.<br>下面是我的第一个站点的配置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name       www.bblove.me bblove.me;</span><br><span class="line">    server_tokens     off;</span><br><span class="line"></span><br><span class="line">    access_log /home/chen/www/nginx_log/bblove_me.log;</span><br><span class="line">    <span class="comment">#access_log        /dev/null;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$request_method</span> !~ ^(GET|HEAD|POST)$ ) &#123;</span><br><span class="line">        <span class="built_in">return</span>        444;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ^~ /.well-known/acme-challenge/ &#123;</span><br><span class="line">        <span class="built_in">alias</span>         /home/chen/www/nginx_acme/bblove_me/.well-known/acme-challenge/;</span><br><span class="line">        try_files     <span class="variable">$uri</span> =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        rewrite       ^/(.*)$ https://bblove.me/<span class="variable">$1</span> permanent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">        listen 443 ssl http2 fastopen=3 reuseport;</span><br><span class="line"></span><br><span class="line">        server_name bblove.me;</span><br><span class="line">        server_tokens   off;</span><br><span class="line">        access_log /home/chen/www/nginx_log/bblove_me.log;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ssl_certificate /home/chen/www/nginx_ssl/bblove_me/bblove_me.cer;</span><br><span class="line">        ssl_certificate_key     /home/chen/www/nginx_ssl/bblove_me/bblove_me.key;</span><br><span class="line"></span><br><span class="line">truetrue<span class="comment">#使用openssl dhparam -out dhparams.pem 2048命令生成该文件,将下面配置注释也许</span></span><br><span class="line">        ssl_dhparam    /home/chen/www/nginx_ssl/dhparams.pem;</span><br><span class="line"></span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">truetrue<span class="comment">#下面是推荐的加密算法配置,但是在我的机器上有bug,chacha20算法无法正常工作,所以我去掉了其中包含chacha20的算法</span></span><br><span class="line">truetrue<span class="comment"># https://github.com/cloudflare/sslconfig/blob/master/conf</span></span><br><span class="line">    <span class="comment">#ssl_ciphers                EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span></span><br><span class="line">        ssl_ciphers                EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ssl_protocols              TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line"></span><br><span class="line">        ssl_session_cache          shared:SSL:50m;</span><br><span class="line">        ssl_session_timeout        1d;</span><br><span class="line"></span><br><span class="line">        ssl_session_tickets        on;</span><br><span class="line">        ssl_stapling    on;</span><br><span class="line">        ssl_stapling_verify     on;</span><br><span class="line">        ssl_trusted_certificate /home/chen/www/nginx_ssl/bblove_me/bblove_me.cer;</span><br><span class="line">        resolver        114.114.114.114 valid=300s;</span><br><span class="line">        resolver_timeout        10s;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$request_method</span> !~ ^(GET|HEAD|POST|OPTIONS)$ ) &#123;</span><br><span class="line">                <span class="built_in">return</span>           444;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$host</span> != <span class="string">'bblove.me'</span>)&#123;</span><br><span class="line">                rewrite ^/(.*)$ https://bblove.me/<span class="variable">$1</span> permanent;</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">                root /home/chen/www/bblove_me;</span><br><span class="line">                index index.html index.htm;</span><br><span class="line">                add_header               Strict-Transport-Security <span class="string">"max-age=31536000; includeSubDomains; preload"</span>;</span><br><span class="line">                add_header               X-Frame-Options deny;</span><br><span class="line">                add_header               X-Content-Type-Options nosniff;</span><br><span class="line">                add_header               Cache-Control no-cache;</span><br><span class="line">                add_header               x-xss-protection <span class="string">" 1; mode=block"</span>;</span><br><span class="line">                add_header               x-content-type-options nosniff;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是我第二个站点的配置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">truelisten 443 ssl http2;</span><br><span class="line"></span><br><span class="line">trueserver_name www.huirongis.me huirongis.me;</span><br><span class="line">trueserver_tokensoff;</span><br><span class="line">trueaccess_log /home/chen/www/nginx_log/huirongis_me.log;</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line">truessl_certificate/home/chen/www/nginx_ssl/huirongis_me/huirongis_me.cer;</span><br><span class="line">truessl_certificate_key/home/chen/www/nginx_ssl/huirongis_me/huirongis_me.key;</span><br><span class="line">true<span class="comment">#ssl_dhparam/home/chen/www/nginx_ssl/huirongis_me/huirongis_me.cer;</span></span><br><span class="line">truessl_ciphers                EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line">true<span class="comment">#ssl_ciphers                EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span></span><br><span class="line">truessl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">truessl_protocols              TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line"></span><br><span class="line">truessl_session_cache          shared:SSL:50m;</span><br><span class="line">truessl_session_timeout        1d;</span><br><span class="line"></span><br><span class="line">truessl_session_tickets        on;</span><br><span class="line">truessl_staplingon;</span><br><span class="line">truessl_stapling_verifyon;</span><br><span class="line">truessl_trusted_certificate/home/chen/www/nginx_ssl/huirongis_me/huirongis_me.cer;</span><br><span class="line">trueresolver114.114.114.114 valid=300s;</span><br><span class="line">trueresolver_timeout10s;</span><br><span class="line">true<span class="keyword">if</span> (<span class="variable">$request_method</span> !~ ^(GET|HEAD|POST|OPTIONS)$ ) &#123;</span><br><span class="line">        <span class="built_in">return</span>           444;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="keyword">if</span> (<span class="variable">$host</span> != <span class="string">'huirongis.me'</span>)&#123;</span><br><span class="line">truetruerewrite ^/(.*)$ https://huirongis.me/<span class="variable">$1</span> permanent;</span><br><span class="line">true&#125;</span><br><span class="line">truelocation / &#123;</span><br><span class="line">truetrueroot /home/chen/www/huirongis_me;</span><br><span class="line">truetrueindex index.html index.htm;</span><br><span class="line">true        add_header               Strict-Transport-Security <span class="string">"max-age=31536000; includeSubDomains; preload"</span>;</span><br><span class="line">truetrueadd_header               X-Frame-Options deny;</span><br><span class="line">true        add_header               X-Content-Type-Options nosniff;</span><br><span class="line">truetrueadd_header               Cache-Control no-cache;</span><br><span class="line">truetrueadd_header x-xss-protection <span class="string">" 1; mode=block"</span>;</span><br><span class="line">truetrueadd_header x-content-type-options nosniff;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    server_name       www.huirongis.me huirongis.me;</span><br><span class="line">    server_tokens     off;</span><br><span class="line"></span><br><span class="line">    access_log        /dev/null;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$request_method</span> !~ ^(GET|HEAD|POST)$ ) &#123;</span><br><span class="line">        <span class="built_in">return</span>        444;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ^~ /.well-known/acme-challenge/ &#123;</span><br><span class="line">        <span class="built_in">alias</span>         /home/chen/www/nginx_acme/huirongis_me/.well-known/acme-challenge/;</span><br><span class="line">        try_files     <span class="variable">$uri</span> =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        rewrite       ^/(.*)$ https://huirongis.me/<span class="variable">$1</span> permanent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该配置的主体内容,都是参考的屈大的配置,但是由于屈大的是单站点,所以为了对应多站点,做了一些改动.</p><ul><li>改动1: server的第一行listen <code>fastopen=3 reuseport</code>的选项,只能用在一个站点上,不能两个站点都加这段配置</li><li>改动2: ssl_dhparam    配置,另外一个站点我懒得弄了,你可以自己生成文件,两个站点都配上.</li></ul><p>有些配置的含义和原理,屈大都给了详细的分析,想了解的可以去看看.</p><p>再贴一下本站目录结构:<br><img src="https://ws1.sinaimg.cn/large/692869a3gy1fgivj9x7g0j20nj0ert9g.jpg" alt="本站目录设置"></p><h1 id="4-修改http资源为https"><a href="#4-修改http资源为https" class="headerlink" title="4 修改http资源为https"></a>4 修改http资源为https</h1><p>ok,都这里基本都搞定了,应该可以看到小绿锁了.在chrome中按<code>F12</code>-&gt;<code>console</code>,查看原因.如果你的网站中包含其他第三方http资源,可能会没有看到小绿锁,只需要将http资源修改为https的就行,比如图片资源,本站使用新浪微博图床,只需要将原来的http格式的图片加个s,变成https就可以了.如果资源没有https的,那就需要将资源下载到服务器本地.<br><img src="https://ws1.sinaimg.cn/large/692869a3gy1fecyz408dqj20yc0ga431.jpg" alt="小绿锁"><br>至此,整个网站的https配置完成.</p><h1 id="5-问题和优化"><a href="#5-问题和优化" class="headerlink" title="5 问题和优化"></a>5 问题和优化</h1><p>现在还有问题没有解决:</p><ul><li>加密算法的问题,我的服务器配置chacha20算法不成功,只要客户端协商的算法中有chacha20,服务器就会返回<code>bad record mac</code>错误,现在我只能把它禁用</li><li>证书的自动更新问题,由于我后期还配置了其他的东西,所以证书自动更新一直不成功,需要我手动去更新</li><li>将域名提交到<a href="https://hstspreload.org/,具体原理请参考[合理使用](https://imququ.com/post/sth-about-switch-to-https.html#toc-2)" target="_blank" rel="noopener">https://hstspreload.org/,具体原理请参考[合理使用](https://imququ.com/post/sth-about-switch-to-https.html#toc-2)</a></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://imququ.com/post/sth-about-switch-to-https-2.html" target="_blank" rel="noopener">关于启用 HTTPS 的一些经验分享（二）</a></li><li><a href="https://imququ.com/post/my-nginx-conf.html" target="_blank" rel="noopener">本博客 Nginx 配置之完整篇</a></li><li><a href="https://imququ.com/post/sth-about-switch-to-https.html#toc-2" target="_blank" rel="noopener">关于启用 HTTPS 的一些经验分享（一）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2017-06-13 修改证书生成目录,为方便后续的git push自动更新,将acme验证目录移出网站根目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此处接上篇&lt;a href=&quot;https://bblove.me/20
      
    
    </summary>
    
      <category term="Linux" scheme="https://bblove.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://bblove.me/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://bblove.me/tags/Nginx/"/>
    
      <category term="ubunt" scheme="https://bblove.me/tags/ubunt/"/>
    
  </entry>
  
  <entry>
    <title>在ubuntu上安装和配置Nginx</title>
    <link href="https://bblove.me/2017/04/05/nginx-installation-and-setting-in-ubuntu-server/"/>
    <id>https://bblove.me/2017/04/05/nginx-installation-and-setting-in-ubuntu-server/</id>
    <published>2017-04-05T02:51:24.000Z</published>
    <updated>2018-05-30T01:57:59.325Z</updated>
    
    <content type="html"><![CDATA[<p>废话:最近一直想写博客,憋了好几篇,但是一直没时间,从年前拖到了年后,一直拖到4月份,真是伤不起,不过,总算开动了</p><h1 id="1-系统环境"><a href="#1-系统环境" class="headerlink" title="1 系统环境"></a>1 系统环境</h1><p>服务器:ubuntu server 16.04.2 LTS<br>主要工具:xshell</p><p>我这个服务器是腾讯云的主机,装的最新的ubuntu server lts发行版,32位系统.</p><h1 id="2-系统安装"><a href="#2-系统安装" class="headerlink" title="2 系统安装"></a>2 系统安装</h1><p>我这里是完全参考的屈大的教程,因为屈大教程会不断更新,所以我这里就不赘述,直接贴地址<br><a href="https://imququ.com/post/my-nginx-conf.html" title="本博客Nginx配置之完整篇" target="_blank" rel="noopener">https://imququ.com/post/my-nginx-conf.html</a></p><p>ps:由于屈大的Nginx配置是https一步到位,我的建议是,刚开始玩的话,先把所以https相关的配置注释掉,等一切顺利跑起来了,后期再加上https的内容</p><p><code>Nginx全局配置</code>,直接抄屈大的就行,只需要把最后一行,改成你自己的服务器的路径<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>            <span class="regexp">/home/</span>jerry<span class="regexp">/www/</span>nginx_conf<span class="comment">/*.conf;</span></span><br></pre></td></tr></table></figure></p><p><code>web站点配置</code>注释掉https相关内容后,如下(我修改了屈大部分目录的路径,原理一样的):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        server_name bblove.me www.bblove.me;</span><br><span class="line">        server_tokens   off;</span><br><span class="line">        access_log /home/chen/www/nginx_log/bblove_me.log;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_certificate /home/chen/www/nginx_ssl/bblove_me/bblove_me.cer;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_certificate_key     /home/chen/www/nginx_ssl/bblove_me/bblove_me.key;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_dhparam    /home/chen/www/nginx_ssl/dhparams.pem;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_prefer_server_ciphers  on;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_ciphers                EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">       ssl_protocols              TLSv1 TLSv1.1 TLSv1.2;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">       ssl_session_cache          shared:SSL:50m;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_session_timeout        1d;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">       ssl_session_tickets        on;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_stapling    on;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_stapling_verify     on;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        ssl_trusted_certificate /home/chen/www/nginx_ssl/bblove_me/bblove_me.cer;</span></span><br><span class="line">        resolver        114.114.114.114 valid=300s;</span><br><span class="line">        resolver_timeout        10s;</span><br><span class="line">        if ($request_method !~ ^(GET|HEAD|POST|OPTIONS)$ ) &#123;</span><br><span class="line">                return           444;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">        <span class="keyword">if</span> (<span class="variable">$host</span> != <span class="string">'bblove.me'</span>)&#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                rewrite ^/(.*)$ https://bblove.me/<span class="variable">$1</span> permanent;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        &#125;</span></span><br><span class="line">        location / &#123;</span><br><span class="line">                root /home/chen/www/bblove_me;</span><br><span class="line">                index index.html index.htm;</span><br><span class="line">                add_header               Strict-Transport-Security "max-age=31536000; includeSubDomains; preload";</span><br><span class="line">                add_header               X-Frame-Options deny;</span><br><span class="line">                add_header               X-Content-Type-Options nosniff;</span><br><span class="line">                add_header               Cache-Control no-cache;</span><br><span class="line">                add_header               x-xss-protection " 1; mode=block";</span><br><span class="line">                add_header               x-content-type-options nosniff;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置完成后,使用<code>sudo service nginx reload</code>,重新加载配置文件,如果没有生效,就重启一下服务器.如果服务出错,可以使用<code>sudo service nginx status</code>查看是哪一行的配置出错,修改以后再reload.<br>到此步,服务器应该就配置好了,可以使用ip访问你的服务器了<code>http://x.x.x.x</code>,此处如果无法访问,请查看<br><a href="#4-结尾">安全组配置</a>,检查是否开放了80端口</p><h1 id="3-修改DNS配置"><a href="#3-修改DNS配置" class="headerlink" title="3 修改DNS配置"></a>3 修改DNS配置</h1><p>我使用的DNSPOD的服务,直接去管理后台,添加两条解析记录,将<code>www</code>和<code>@</code>添加A记录,指向自己的服务器ip.<br>如果你不添加<code>www</code>的话,那访问你的博客只能使用<code>bblove.me</code>访问.添加两条记录的话,<code>www.bblove.me</code>和<code>bblove.me</code>都可访问你的博客.<br>而且,后面配置<code>https</code>的时候,如果要上HSTS的功能,就必须要配置<code>www</code>.<br><img src="https://ws1.sinaimg.cn/large/692869a3gy1febmtogaq5j20v904gglw.jpg" alt="DNSPOD配置"><br>配置好之后,可能要等一会儿才会生效<br>到这一步,你的服务器应该就可以使用域名访问了,http://域名</p><h1 id="4-本站目录设置"><a href="#4-本站目录设置" class="headerlink" title="4 本站目录设置"></a>4 本站目录设置</h1><p>本站因为后期会布置多站点,所以设置目录结构如下,<code>www</code>目录下包含两个域名对应的网站根目录,同时还设置了配置文件的目录,日志文件的目录,https证书相关目录等,如图所示.</p><p><img src="https://ws1.sinaimg.cn/large/692869a3gy1fecyn6c5hyj20fg0hn0tc.jpg" alt="本站目录设置"></p><h1 id="5-结尾"><a href="#5-结尾" class="headerlink" title="5 结尾"></a>5 结尾</h1><p>我把多站点配置和https配置放到下一篇博客,这篇就简单讲这么多吧.</p><p>小建议:</p><ul><li>配置Nginx的时候善用<code>sudo service nginx status</code>,这个用来定位错误很方便</li><li>如果使用云服务器,比如腾讯云的话,需要修改安全组策略,把80端口和443端口放开<img src="https://ws1.sinaimg.cn/large/692869a3gy1febolh4yq0j21170fiq4b.jpg" alt="安全组配置"></li><li>如果想查看端口是否打开,可以使用<a href="http://tool.chinaz.com/port/" target="_blank" rel="noopener">站长工具-在线端口扫描</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;废话:最近一直想写博客,憋了好几篇,但是一直没时间,从年前拖到了年后,一直拖到4月份,真是伤不起,不过,总算开动了&lt;/p&gt;
&lt;h1 id=&quot;1-系统环境&quot;&gt;&lt;a href=&quot;#1-系统环境&quot; class=&quot;headerlink&quot; title=&quot;1 系统环境&quot;&gt;&lt;/a&gt;1 系
      
    
    </summary>
    
      <category term="Linux" scheme="https://bblove.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://bblove.me/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://bblove.me/tags/Nginx/"/>
    
      <category term="ubuntu" scheme="https://bblove.me/tags/ubuntu/"/>
    
      <category term="多站点" scheme="https://bblove.me/tags/%E5%A4%9A%E7%AB%99%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>2016这过去的半年</title>
    <link href="https://bblove.me/2016/11/06/my-life-these-days/"/>
    <id>https://bblove.me/2016/11/06/my-life-these-days/</id>
    <published>2016-11-06T07:39:32.000Z</published>
    <updated>2018-05-30T01:57:59.313Z</updated>
    
    <content type="html"><![CDATA[<p>时间真是匆匆啊,上一篇博客的时间是3月25,今天都已经是11月6号了,过去了7个多月.<br><a id="more"></a></p><h1 id="1-时光匆匆"><a href="#1-时光匆匆" class="headerlink" title="1 时光匆匆"></a>1 时光匆匆</h1><p>自从上了初中开始,就发觉时间过得快来.接下来到了高中时间有是更快了,到了大学时间简直飞逝.<br>人生黄金的10年,转眼已经过了一般,but我依旧没有成为一个大神,还是辣么水水哒.基础知识还是不扎实,做事情总是知其然而不知其所以然,这是我所讨厌的,但是也没有实际的办法.<br>每次遇到一个事情,如果要刨根问底的去解决,就涉及太多的东西,短时间根本没法解决;可是如果选择一个快捷的方法,那么就只是解决了眼前的问题,但是没有实际去搞懂它.等到事情解决,每每又再提不起兴趣去解决.这真是一对矛盾,想快速解决就搞不懂原理,想搞懂原理但是时间又不允许.</p><h1 id="2-找实习"><a href="#2-找实习" class="headerlink" title="2 找实习"></a>2 找实习</h1><p>今年有一个比较大的事情,也是对自己比较重要的事情,找实习.想来也是运气好,和老谭他们比起来真是好太多了.<br>还记得3月份第一个电话是海豚浏览器,我在官网发的邮件,因为海豚不招php没办法投的前端开发,但是一面(可能都不能算是一面),应该是hr面试的就把我刷掉了,额,有点心塞.<br>第二个好像是微博易,这个公司有点坑,技术面是CTO面试的.一般CTO啊CEO啊搞面试,说实话都觉得有点不靠谱,因为说明公司真心小,哭脸.这个技术面真心让我无语,一开始就告诉我这次面试要问几个技术问题,开场是我做个自我介绍,然后简单聊了一下自己的项目.接着事情就不可控了,他问我为什么要做技术,我说是因为自己对技术比较感兴趣,小时候看电影觉得黑客很酷,现在虽然做不成黑客,但是我喜欢电脑,喜欢敲代码.然后他接着问我为什么喜欢,觉得做技术最重要的是什么?我当时内心真是黑人问号了,这完全不按套路出牌啊,一直刨根问底.整个面试持续了1个小时,而且最后结束的时候并没有问任何技术问题,真是醉了.记得当时在实验室面试的,面完之后,我师弟开口问,师兄你刚才是HR面吗?你就知道这个面试有多坑了,这哪是技术面啊,工程师为啥会问这些问题?那要HR做什么?<br>再往后的面试就顺利多了,拿了盛大游戏的offer(内部应用系统开发),美图offer(这个职位应该是比较好的,但是在厦门),华米科技(这个是我打算去的,对小米的东西也比较有兴趣),百度地图offer.拿了百度的以后就没有再面试了.对于华米科技的那个面试官还是挺抱歉的,聊的也比较开心,因为华米科技算是创业公司应该还是能很好的锻炼,无奈百度的名气大,最后还是选择了百度,只能拒掉华米科技了.</p><h1 id="3-去实习"><a href="#3-去实习" class="headerlink" title="3 去实习"></a>3 去实习</h1><p>拿到口头offer以后,在漫长的等待书面offer中.回家住了几天,和家人一起上了去天堂寨旅游了一把,放松一下.<br>最后出发北上的晚上,我最亲爱的请我吃了一顿烧烤,恩,我喜欢烧烤.我俩还喝了一瓶啤酒,哈哈.<img src="https://ws4.sinaimg.cn/large/692869a3gw1f9ihai0a6nj21kw23u4qp.jpg" alt="武汉出发时"><br>接着一路北上,我坐的硬座,额,必须是为了省钱,现在想想,也是蛮艰苦的.</p><h2 id="3-1-找房子"><a href="#3-1-找房子" class="headerlink" title="3.1 找房子"></a>3.1 找房子</h2><p>刚到北京,北京的旅社真是贵,七天如家什么的一天要200-300多,我表示完全住不起啊,最后选择住青年旅社,一天80多块钱.幸亏我弟在北京念书,我可以把行李放在他那里,青年旅社自己带的东西不敢放,怕被偷.那也是我第一次住青年旅社,还是很紧张的,睡觉把书包都抱着.<br>找房子绝对是最艰难的事情,跑了两天,全是中介,根本就没有没有中介的地方,而且在五道口附加的房子真是贵,一间房子一不小心就要2000多,直逼三千,关键房子还不咋地.还好有同学在,雄风和国安他们先行来到北京,最痛苦的事他们已经趟过了,我在他们那里借住了几天.还好天无绝人之路,我在内网找了几天,总算找打合适的了,虽然离地铁站有点远,但是1600一个月,而且是2室1厅2卫,人少,住着舒服,附近有超市有菜场,生活很方便,室友人也很好,知道我是实习生很照顾我,房租什么的也没催我还说可以等发工资再交.</p><h2 id="3-2-百度第一天"><a href="#3-2-百度第一天" class="headerlink" title="3.2 百度第一天"></a>3.2 百度第一天</h2><p>终于正式去百度实习了,因为上午8点就要开始入职了,所以那天起的很早.<br>上午就是入职流程,领东西然后去大厦听hr培训,然后再分到各个地方.我入职的地方是奎科大厦,不过说真的,还是更喜欢百度大厦或者科技园,哈哈,新修的大楼看起来爽多了,啥都是新的,更有归属感.<br>中午11点多的时候,来到了自己的工位,经理向大家介绍我,接着介绍每个人的名字,额,差不多一个都没记住,还好工位每个人都有明牌,哈哈.<br>下午的时候,就是熟悉一下环境,搭建开发环境申请开发机什么的,都是mentor在教我.<br>第一天的感觉,就是好累,可能早上起太早了,也可能是房子还没确定,当天下班的时候感觉好累,就拍了这一张照片.<br><img src="https://ws4.sinaimg.cn/large/692869a3gw1f9ih2uc5xhj20x617s45c.jpg" alt="在百度的第一天"></p><h2 id="3-4-在百度"><a href="#3-4-在百度" class="headerlink" title="3.4 在百度"></a>3.4 在百度</h2><p>之前做的项目,都算是小打小闹,这次进去公司实习确实有不一样的感受.</p><ol><li><code>要对自己的每一行代码负责</code>:以前写代码都是只看最后的运行效果,出来了就行了,其实都没搞清楚每一行代码每一个变量的具体输出和值,测试也不充分.公司写代码,必须要自己对自己的代码负责,刚开始去就吃了这方面的苦,第一次代码上线都出了问题,所以后来排期的时候,代码自己review的时间都特别长,有时候和开发时间差不多.</li><li><code>系统设计能力很重要</code>:之前都是提了需求,考虑一下,就开始动手写代码了.不过一般来说,当一个需求确定的时候,我自己心里就有了一个大概的构图,有个谱了.到公司的感觉就是,同事之间的经验比我还是丰富很多,所以前期的时候很看重设计能力,还专门开会大家讨论,确定方案后,才动手写代码.</li><li><code>多学习,多看书</code>:同事空闲时候都在学习别的东西,看其他书籍,这是一个好习惯,我喜欢.</li></ol><h2 id="3-5-与人相处"><a href="#3-5-与人相处" class="headerlink" title="3.5 与人相处"></a>3.5 与人相处</h2><p>在公司和学校还是有很大区别的,学校每天都是和室友混在一起,一起吃饭,一起去实验室,一起玩游戏.到公司,刚开始感觉大家的感觉就疏远很多,大家彼此相互尊重,感觉就是少了学校同学的那份亲密.刚开始我还试图融入他们的圈子,不过因为自己不善言辞,做的并不好.<br>大概一个月过后,就觉悟了,在公司和在学校本来就不同,大家的关系也无法做到像学校那样,所以不必强求,大家友好和平共处,就是正确的处理方式.正如圣哥所说,大家其实都是过客.<br>后面的相处就自然的多,简简单单相处.</p><hr><p>2016-11-06 17:25  就先写到这,吃饭去的,等下食堂就没饭了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间真是匆匆啊,上一篇博客的时间是3月25,今天都已经是11月6号了,过去了7个多月.&lt;br&gt;
    
    </summary>
    
      <category term="杂文" scheme="https://bblove.me/categories/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="生活" scheme="https://bblove.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>HTTP1.0和HTTP1.1的区别</title>
    <link href="https://bblove.me/2016/03/25/http-1-0-vs-1-1/"/>
    <id>https://bblove.me/2016/03/25/http-1-0-vs-1-1/</id>
    <published>2016-03-25T05:36:53.000Z</published>
    <updated>2018-05-30T01:57:59.312Z</updated>
    
    <content type="html"><![CDATA[<p>今天研究了下HTTP,还是挺有意思的.<br>接下来,就比较一下两者的区别.<br><a id="more"></a></p><h1 id="1-长连接"><a href="#1-长连接" class="headerlink" title="1 长连接"></a>1 长连接</h1><p>这个应该是变化最大的一个了.在1.0的版本中,如果客户端请求头没有设置<code>Connection: Keep-Alive</code>的话,那么每次请求完成都会立即断开连接,然后客户端又要重新建立一个HTTP连接.假设一个网页包含了10个图片,那么为了请求图片,客户端必须要发送10次请求,无疑这对带宽和资源是极大的浪费,TCP的优势就没有体现出来.<br>在HTTP1.1中,<code>keep-Alive</code>已经被弃用(但是大多数服务器和浏览器都还保留这个选项).在1.1的版本中,持久连接默认就是启用的,除非你显式在响应头部包含<code>Connection: close</code>,客户端收到响应后才会关闭连接.</p><h1 id="2-host头域"><a href="#2-host头域" class="headerlink" title="2 host头域"></a>2 host头域</h1><p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址,因此,请求消息中的URL并没有传递主机名(hostname).但随着虚拟主机技术的发展,在一台物理服务器上可以存在多个虚拟主机(Multi-homed Web Servers),并且它们共享一个IP地址.<br>HTTP1.1的请求消息和响应消息都应支持<code>Host</code>头域,且请求消息中如果没有<code>Host</code>头域会报告一个错误(400 Bad Request).此外,服务器应该接受以绝对路径标记的资源请求.</p><h1 id="3-请求方法"><a href="#3-请求方法" class="headerlink" title="3 请求方法"></a>3 请求方法</h1><p>HTTP1.1增加了<code>OPTIONS</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>CONNECT</code>这些Request方法.<br>       Method         = <strong>“OPTIONS”</strong>               ; Section 9.2<br>                      | “GET”                    ; Section 9.3<br>                      | “HEAD”                   ; Section 9.4<br>                      | “POST”                   ; Section 9.5<br>                      | <strong>“PUT”</strong>                   ; Section 9.6<br>                      | <strong>“DELETE”</strong>                 ; Section 9.7<br>                      | <strong>“TRACE”</strong>               ; Section 9.8<br>                      | <strong>“CONNECT”</strong>                ; Section 9.9<br>                      | extension-method<br>       extension-method = token<br>HTTP1.1 增加的新的status code：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(HTTP1.0没有定义任何具体的1xx status code, HTTP1.1有2个)</span><br><span class="line">100 Continue</span><br><span class="line">101 Switching Protocols</span><br><span class="line">203 Non-Authoritative Information</span><br><span class="line">205 Reset Content</span><br><span class="line">206 Partial Content</span><br><span class="line">302 Found (在HTTP1.0中有个 302 Moved Temporarily)</span><br><span class="line">303 See Other</span><br><span class="line">305 Use Proxy</span><br><span class="line">307 Temporary Redirect</span><br><span class="line">405 Method <span class="keyword">Not</span> Allowed</span><br><span class="line">406 <span class="keyword">Not</span> Acceptable</span><br><span class="line">407<span class="built_in"> Proxy </span>Authentication Required</span><br><span class="line">408 Request Timeout</span><br><span class="line">409 Conflict</span><br><span class="line">410 Gone</span><br><span class="line">411 Length Required</span><br><span class="line">412 Precondition Failed</span><br><span class="line">413 Request Entity Too Large</span><br><span class="line">414 Request-URI Too Long</span><br><span class="line">415 Unsupported Media Type</span><br><span class="line">416 Requested Range <span class="keyword">Not</span> Satisfiable</span><br><span class="line">417 Expectation Failed</span><br><span class="line">504 Gateway Timeout</span><br><span class="line">505 HTTP Version <span class="keyword">Not</span> Supported</span><br></pre></td></tr></table></figure></p><h1 id="4-内容长度"><a href="#4-内容长度" class="headerlink" title="4 内容长度"></a>4 内容长度</h1><p>通常,HTTP应答消息中发送的数据是整个发送的,<code>Content-Length</code>消息头字段表示数据的长度.数据的长度很重要,因为客户端需要知道哪里是应答消息的结束,以及后续应答消息的开始.但是在一些动态网页中,由于网页是动态生成的,所以没法计算出准确的<code>Content-Length</code>,这样导致的后果是:如果 <code>Content-Length</code> 比实际长度短,会造成内容被截断;如果比实体内容长,会造成 pending,浏览器一直转圈圈.<br>所以在HTTP1.1中引入了<code>Transfer-Encoding</code>,如果一个HTTP消息(请求消息或应答消息)的<code>Transfer-Encoding</code>消息头的值为chunked,那么,消息体由数量未定的块组成,并以最后一个大小为0的块为结束.<br>ps:如果同时设置了<code>Content-Length</code> 和<code>Transfer-Encoding</code>,那么<code>Transfer-Encoding</code>的优先级更高,<code>Content-Length</code>会被忽略.</p><h1 id="5-缓存"><a href="#5-缓存" class="headerlink" title="5 缓存"></a>5 缓存</h1><ul><li>在HTTP/1.0中,使用<code>Expire</code>头域来判断资源的<code>fresh</code>或<code>stale</code>,并使用条件请求(conditional request)来判断资源是否仍有效.例如,cache服务器通过<code>If-Modified-Since</code>头域向服务器验证资源的<code>Last-Modefied</code>头域是否有更新,源服务器可能返回304(Not Modified),则表明该对象仍有效;也可能返回200(OK)替换请求的Cache对象.</li><li>此外,HTTP/1.0中还定义了<code>Pragma:no-cache</code>头域,客户端使用该头域说明请求资源不能从cache中获取,而必须回源获取.</li><li>HTTP/1.1在1.0的基础上加入了一些cache的新特性,当缓存对象的Age超过<code>Expire</code>时变为<code>stale</code>对象,cache不需要直接抛弃<code>stale</code>对象,而是与源服务器进行重新激活(revalidation).</li><li>HTTP/1.0中,<code>If-Modified-Since</code>头域使用的是绝对时间戳,精确到秒,但使用绝对时间会带来不同机器上的时钟同步问题.而HTTP/1.1中引入了一个<code>ETag</code>头域用于重激活机制,它的值<code>entity tag</code>可以用来唯一的描述一个资源.请求消息中可以使用<code>If-None-Match</code>头域来匹配资源的<code>entitytag</code>是否有变化.</li><li>为了使caching机制更加灵活,HTTP/1.1增加了<code>Cache-Control</code>头域(请求消息和响应消息都可使用),它支持一个可扩展的指令子集：例如<code>max-age</code>指令支持相对时间戳;<code>private</code>和<code>no-store</code>指令禁止对象被缓存;<code>no-transform</code>阻止Proxy进行任何改变响应的行为.</li><li>Cache使用关键字索引在磁盘中缓存的对象,在HTTP/1.0中使用资源的URL作为关键字.但可能存在不同的资源基于同一个URL的情况,要区别它们还需要客户端提供更多的信息,如<code>Accept-Language</code>和<code>Accept-Charset</code>头域.为了支持这种内容协商机制(content negotiation mechanism),HTTP/1.1在响应消息中引入了Vary头域,该头域列出了请求消息中需要包含哪些头域用于内容协商.</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>1 <a href="HTTPs://imququ.com/post/transfer-encoding-header-in-HTTP.html" target="_blank" rel="noopener">HTTP 协议中的 Transfer-Encoding</a><br>2 <a href="http://blog.csdn.net/forgotaboutgirl/article/details/6936982" target="_blank" rel="noopener">HTTP/1.1与HTTP/1.0的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天研究了下HTTP,还是挺有意思的.&lt;br&gt;接下来,就比较一下两者的区别.&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="https://bblove.me/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="https://bblove.me/tags/Linux/"/>
    
      <category term="HTTP" scheme="https://bblove.me/tags/HTTP/"/>
    
      <category term="apache" scheme="https://bblove.me/tags/apache/"/>
    
  </entry>
  
  <entry>
    <title>解决倒水问题</title>
    <link href="https://bblove.me/2016/03/19/how-to-solve-the-water-problem/"/>
    <id>https://bblove.me/2016/03/19/how-to-solve-the-water-problem/</id>
    <published>2016-03-19T04:48:58.000Z</published>
    <updated>2018-05-30T01:57:59.314Z</updated>
    
    <content type="html"><![CDATA[<p>有两个容器，容积分别为A升和B升，有无限多的水，现在需要C升水。<br>我们还有一个足够大的水缸，足够容纳C升水。起初它是空的，我们只能往水缸里倒入水，而不能倒出。<br>可以进行的操作是：<br>把一个容器灌满；<br>把一个容器清空（容器里剩余的水全部倒掉，或者倒入水缸）；<br>用一个容器的水倒入另外一个容器，直到倒出水的容器空或者倒入水的容器满。<br>    问是否能够通过有限次操作，使得水缸最后恰好有C升水。<br><a id="more"></a><br>这是很经典的智力题,各种倒水,求怎么倒.<br>网上有很多资料,我稍微总结下.</p><h1 id="1-是否有解"><a href="#1-是否有解" class="headerlink" title="1 是否有解"></a>1 是否有解</h1><p>是的,不是任意的ABC值都是有解的,比如用4升和6升的容器,倒出5升水,这个方案就是无解的.<br>总结来说:<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">倒水方案有解的,充要条件是:</span><br><span class="line">C&lt;=<span class="keyword">A</span>+B并且</span><br><span class="line">C能被<span class="keyword">A</span>和B的最大公约数整除</span><br></pre></td></tr></table></figure></p><p>比如上面的例子,4和6的公约数是2,5不能被2整除,所以是无解的.<br>具体证明过程请看文章后面的参考文献</p><h1 id="2-解法"><a href="#2-解法" class="headerlink" title="2 解法"></a>2 解法</h1><p>有一个很简单的思路,在AB两个容器中,假设A&lt;B,那么我们不停地用A往B中加水,溢出的时候,就把B清空,把A中多余部分导入B中.具体流程描述如下<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A%<span class="attribute">B</span>=x</span><br><span class="line">2A%<span class="attribute">B</span>=y</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">nA%<span class="attribute">B</span>=z</span><br></pre></td></tr></table></figure></p><p>知道最后余数z等于C,就停止<br>用一个具体的例子<br><code>A=5</code>,<code>B=9</code>,<code>C=7</code><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>%<span class="number">9</span>=<span class="number">5</span></span><br><span class="line"><span class="number">10</span>%<span class="number">9</span>=<span class="number">1</span></span><br><span class="line"><span class="number">15</span>%<span class="number">9</span>=<span class="number">6</span></span><br><span class="line"><span class="number">20</span>%<span class="number">9</span>=<span class="number">2</span></span><br><span class="line"><span class="number">25</span>%<span class="number">9</span>=<span class="number">7</span></span><br></pre></td></tr></table></figure></p><p>也就完成了查找<br>当然这个方法不是步数最少的解法</p><p><a href="http://www.acmerblog.com/pour-water-problem-5615.html" target="_blank" rel="noopener">倒水问题</a><br><a href="http://www.cnblogs.com/frog112111/archive/2012/08/19/2646012.html" target="_blank" rel="noopener">欧几里得和扩展欧几里得算法</a><br><a href="http://www.cnblogs.com/drizzlecrj/archive/2007/09/14/892340.html" target="_blank" rel="noopener">最大公约数的三种解法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两个容器，容积分别为A升和B升，有无限多的水，现在需要C升水。&lt;br&gt;我们还有一个足够大的水缸，足够容纳C升水。起初它是空的，我们只能往水缸里倒入水，而不能倒出。&lt;br&gt;可以进行的操作是：&lt;br&gt;把一个容器灌满；&lt;br&gt;把一个容器清空（容器里剩余的水全部倒掉，或者倒入水缸）；&lt;br&gt;用一个容器的水倒入另外一个容器，直到倒出水的容器空或者倒入水的容器满。&lt;br&gt;    问是否能够通过有限次操作，使得水缸最后恰好有C升水。&lt;br&gt;
    
    </summary>
    
    
      <category term="智力题" scheme="https://bblove.me/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>php学习笔记(4)--php中cookie没有及时生效</title>
    <link href="https://bblove.me/2016/03/19/php-learn-note-5/"/>
    <id>https://bblove.me/2016/03/19/php-learn-note-5/</id>
    <published>2016-03-19T04:15:32.000Z</published>
    <updated>2018-05-30T01:57:59.324Z</updated>
    
    <content type="html"><![CDATA[<p>update:2016/4/14 9:48:26<br>这是最近才在面试题中发现的一个问题,之前用的时候还没发现,仔细一想,有点意思.<br><a id="more"></a></p><h1 id="1-php中的cookie"><a href="#1-php中的cookie" class="headerlink" title="1 php中的cookie"></a>1 php中的cookie</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;update:2016/4/14 9:48:26&lt;br&gt;这是最近才在面试题中发现的一个问题,之前用的时候还没发现,仔细一想,有点意思.&lt;br&gt;
    
    </summary>
    
      <category term="php学习笔记" scheme="https://bblove.me/categories/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="php" scheme="https://bblove.me/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>php学习笔记(4)--php使用mysqli连接数据库</title>
    <link href="https://bblove.me/2016/03/12/php-learn-note-4/"/>
    <id>https://bblove.me/2016/03/12/php-learn-note-4/</id>
    <published>2016-03-12T02:18:31.000Z</published>
    <updated>2018-05-30T01:57:59.325Z</updated>
    
    <content type="html"><![CDATA[<p>long time no see,用上框架以后,好久没有写原生的sql处理了,想当年用的还是mysql_connect,如今,都已经换mysqli了.<br><a id="more"></a></p><h1 id="1-关于php的数据库连接方式"><a href="#1-关于php的数据库连接方式" class="headerlink" title="1 关于php的数据库连接方式"></a>1 关于php的数据库连接方式</h1><p>当考虑连接到MySQL数据库服务器的时候，有三种主要的API可供选择：<br>1 PHP的MySQL扩展<br>2 PHP的mysqli扩展<br>3 PHP数据对象(PDO)</p><h2 id="1-1-什么是PHP的MySQL扩展"><a href="#1-1-什么是PHP的MySQL扩展" class="headerlink" title="1.1 什么是PHP的MySQL扩展?"></a>1.1 什么是PHP的MySQL扩展?</h2><p>这是设计开发允许PHP应用与MySQL数据库交互的早期扩展。mysql扩展提供了一个面向过程 的接口，并且是针对MySQL4.1.3或更早版本设计的。因此，这个扩展虽然可以与MySQL4.1.3或更新的数据库服务端 进行交互，但并不支持后期MySQL服务端提供的一些特性。</p><h2 id="1-2-什么是PHP的mysqli扩展"><a href="#1-2-什么是PHP的mysqli扩展" class="headerlink" title="1.2 什么是PHP的mysqli扩展?"></a>1.2 什么是PHP的mysqli扩展?</h2><p>mysqli扩展，我们有时称之为MySQL增强扩展，可以用于使用MySQL4.1.3或更新版本中新的高级特性。mysqli扩展在PHP 5及以后版本中包含。<br>1   mysqli扩展有一系列的优势，相对于mysql扩展的提升主要有：<br>2   面向对象接口<br>3   prepared语句支持（译注：关于prepare请参阅mysql相关文档）<br>4   多语句执行支持<br>5   事务支持<br>6   增强的调试能力<br>7   嵌入式服务支持<br>在提供了面向对象接口的同时也提供了一个面向过程的接口。</p><h2 id="1-3-什么是PDO"><a href="#1-3-什么是PDO" class="headerlink" title="1.3 什么是PDO?"></a>1.3 什么是PDO?</h2><p>PHP数据对象，是PHP应用中的一个数据库抽象层规范。PDO提供了一个统一的API接口可以使得你的PHP应用不去关心具体要 连接的数据库服务器系统类型。也就是说，如果你使用PDO的API，可以在任何需要的时候无缝切换数据库服务器，比如从Firebird 到MySQL，仅仅需要修改很少的PHP代码。</p><p>其他数据库抽象层的例子包括Java应用中的JDBC以及Perl中的DBI。</p><p>当然，PDO也有它自己的先进性，比如一个干净的，简单的，可移植的API，它最主要的缺点是会限制让你不能使用 后期MySQL服务端提供所有的数据库高级特性。比如，PDO不允许使用MySQL支持的多语句执行。</p><p><img src="https://ww2.sinaimg.cn/large/692869a3gw1f1tvea7khyj20hm0dhac0.jpg" alt="PHP中三种主要的MySQL连接方式的功能的比较"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;long time no see,用上框架以后,好久没有写原生的sql处理了,想当年用的还是mysql_connect,如今,都已经换mysqli了.&lt;br&gt;
    
    </summary>
    
      <category term="php学习笔记" scheme="https://bblove.me/categories/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="php" scheme="https://bblove.me/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>解决 Github Pages 禁止百度爬虫的方法2--从gitcafe迁移到coding.net</title>
    <link href="https://bblove.me/2016/03/06/migrate-pages-from-gitcafe-to-coding/"/>
    <id>https://bblove.me/2016/03/06/migrate-pages-from-gitcafe-to-coding/</id>
    <published>2016-03-06T07:50:46.000Z</published>
    <updated>2018-05-30T01:57:59.323Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章<a href="http://jackroyal.github.io/2015/11/25/how-to-solve-the-problem-that-github-blocks-the-baidu-spider/" target="_blank" rel="noopener">解决 Github Pages 禁止百度爬虫的方法</a>,提到了解决百度爬虫被github禁用掉的方法.<br><code>把博客同时发布到github pages和gitcafe pages.然后使用dnspod设置域名解析,国内线路解析到gitcafe,国外线路解析到github.</code><br>然后今天去上gitcafe,偶然看到这个<br><img src="https://ww4.sinaimg.cn/large/692869a3gw1f1n79skvt3j20zl0m7k07.jpg" alt="GitCafe 项目迁移至 Coding.net 公告"><br>额(⊙o⊙)…,holly shit.不过没办法,人家都被收购了,我们只能改变策略了.<br>话说,两家都是做代码托管的,这也是顺(bao)应(tuan)潮(qu)流(nuan)咩?<br><a id="more"></a><br>思路跟原来差不多,就是我们把其中的gitcafe内容替换成coding.net就好,以下简称coding.<br><code>把博客同时发布到github pages和coding pages.然后使用dnspod设置域名解析,国内线路解析到coding.net,国外线路解析到github.</code></p><ol><li>注册coding账号</li><li>新建一个项目,名字与你的用户名相同,比如我的名字是<code>Jackroyal</code>,新建一个项目名为<code>Jackroyal</code></li><li>添加ssh公钥</li><li>新建coding-pages分支</li><li>开启pages服务</li><li>修改hexo配置</li><li>修改dns设置<h1 id="1-注册coding账号"><a href="#1-注册coding账号" class="headerlink" title="1 注册coding账号"></a>1 注册coding账号</h1>这个很简单不必说,注册需要填写用户名,邮箱和密码,比如我的用户名就是<code>Jackroyal</code><h1 id="2-新建和用户名同名的项目"><a href="#2-新建和用户名同名的项目" class="headerlink" title="2 新建和用户名同名的项目"></a>2 新建和用户名同名的项目</h1>在注册好账号以后,我们就去新建一个项目,方法和gitcafe不同和gihub类似,就是和用户名同名,一模一样的就行.我的项目名是<code>Jackroyal</code>,项目属性<code>公开</code><br><img src="https://ww4.sinaimg.cn/large/692869a3gw1f1n8d42xljj20qb0hbmzc.jpg" alt="新建同名项目"><h1 id="3-添加ssh公钥"><a href="#3-添加ssh公钥" class="headerlink" title="3 添加ssh公钥"></a>3 添加<code>ssh</code>公钥</h1>首先,我们提交代码库有两种方式,一种是https,一种是ssh,两种方式都可以,但是因为我们使用hexo来发布博客的时候是没有地方输入密码的,所以我们才考虑使用<code>ssh</code>方式,不过也不一定,我们还是可以使用https方式来提交hexo的.<h2 id="3-1-使用ssh方式发布博客"><a href="#3-1-使用ssh方式发布博客" class="headerlink" title="3.1 使用ssh方式发布博客"></a>3.1 使用ssh方式发布博客</h2>我们只需要找到本地的ssh公钥,然后上传到coding上去就行,点击<a href="https://coding.net/user/account/setting/keys" target="_blank" rel="noopener">这里</a>设置.查看本地ssh公钥的方法和上篇博客一样.<br><img src="https://ww2.sinaimg.cn/large/692869a3gw1eye75djqo9j20gj09475k.jpg" alt="使用git客户端查看ssh公钥私钥"><br><img src="https://ww3.sinaimg.cn/large/692869a3gw1eye7c2xpavj20if06dt9w.jpg" alt="查看公钥"><br>复制那一段,然后在coding上添加上去就行<h2 id="3-2-使用https方式发布"><a href="#3-2-使用https方式发布" class="headerlink" title="3.2 使用https方式发布"></a>3.2 使用https方式发布</h2>如果非要使用https方式,也是可以的,核心思路就是在本地做一次<code>push</code>操作就行.</li><li>我们先<code>git clone</code>命令,我的项目就是<code>git clone https://git.coding.net/Jackroyal/Jackroyal.git</code>得到coding上刚才新建的项目.</li><li>克隆完成后,接着我们进到项目目录,我们新建一个文件或者修改一个文件</li><li><code>git add .</code>,把修改提交到暂存区</li><li><code>git commit -m &quot;测试提交&quot;</code>,将修改提交到本地仓库</li><li><code>git push</code>,将修改提交到远程仓库</li><li>接下来,会让你输入用户名和密码,你输入</li><li>然后项目就会提交,因为这个状态会保留下来,你下次在提交就可以不用输入用户名和密码了,这样为我们使用hexo发布代码提供条件<br>ps:这种方式,可能过一段时间又不行了,报错<code>could not read Username for &#39;https://git.coding.net&#39;: Invalid argument</code>,你再做一次上面的操作就行<h1 id="4-新建coding-pages分支"><a href="#4-新建coding-pages分支" class="headerlink" title="4 新建coding-pages分支"></a>4 新建coding-pages分支</h1>当我们可以提交代码的时候,我们先来新建分支,和gitcafe差不多,它需要一个特别的分支名字,而不是像github默认的master分支,名字是<code>coding-pages</code>,如下图所示<br><img src="https://ww4.sinaimg.cn/large/692869a3gw1f1n965hcj0j210r0g3jvk.jpg" alt="新建coding分支"><br>我们把它设为默认分支<h1 id="5-开启pages服务"><a href="#5-开启pages服务" class="headerlink" title="5 开启pages服务"></a>5 开启pages服务</h1>接下来我们需要手动去开启pages服务.在项目主页的<code>pages</code>选项卡,点击开启服务,同时我们,添加域名绑定<br><img src="https://ww3.sinaimg.cn/large/692869a3gw1f1n98oezpej20sv0kxtdb.jpg" alt="开启pages服务"><br>域名绑定我们还要去修改dns解析,我们先用它分配给我们的域名去访问<a href="http://jackroyal.coding.me/" target="_blank" rel="noopener">http://jackroyal.coding.me/</a>,看看能不能正常访问<h1 id="5-修改hexo配置"><a href="#5-修改hexo配置" class="headerlink" title="5 修改hexo配置"></a>5 修改hexo配置</h1>前面的准备工作做得差不多,我们修改博客的配置信息,打开博客根目录的<code>_config.yml</code>文件,格式和之前github的差不多:<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">- <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="string">'https://github.com/Jackroyal/Jackroyal.github.io.git'</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br><span class="line">- <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="string">'https://git.coding.net/Jackroyal/Jackroyal.git'</span></span><br><span class="line">  <span class="attribute">branch</span>: coding-pages</span><br></pre></td></tr></table></figure></li></ol><p>尤其注意在配置的时候注意留空格,这种键值对,比如<code>type: git</code>,其中的冒号后面到git,有个空格的,不然配置文件就会读取错误.<br>还要注意branch名称,分支必须是<code>coding-pages</code><br><strong>PS:如上面所说,我选择的是https方式发布,所以我的repo是https的,如果你选择ssh方式去认证,那么你的地址应该是类似这样的<a href="mailto:`git@git.coding.net" target="_blank" rel="noopener">`git@git.coding.net</a>:Jackroyal/Jackroyal.git`</strong></p><p><img src="https://ww4.sinaimg.cn/large/692869a3gw1f1n9byao2wj20o00gqn0e.jpg" alt="添加coding的repo信息"></p><h1 id="7-修改dns设置"><a href="#7-修改dns设置" class="headerlink" title="7 修改dns设置"></a>7 修改dns设置</h1><p>就像第5步页面提示的,我们要绑定自己的域名,需要去修改dns解析记录,只需要添加一条CNAME指向你的<code>jackroyal.coding.me</code>即可.<br>注意后面加个点,也就是正确的填法是<code>jackroyal.coding.me.</code>,如下图所示.修改完成后大概等几分钟才能生效<br><img src="https://ww4.sinaimg.cn/large/692869a3gw1f1n9m6me2ej20nv09c0us.jpg" alt="修改dns设置"></p><h1 id="8-从gitcafe迁移"><a href="#8-从gitcafe迁移" class="headerlink" title="8 从gitcafe迁移"></a>8 从gitcafe迁移</h1><p>如果我们选择从gitcafe迁移的话,他会把我们原来的博客迁移过来.为了适应coding,你只需要从上面第二步开始就好,尤其注意的是,<code>新建coding-pages分支</code>,<code>新建coding-pages分支</code>,<code>新建coding-pages分支</code>,重要的事情说三遍,因为你迁移过来的分支名称是<code>gitcafe-pages</code>.<br>也就是核心问题,必须有个和用户名同名的项目,项目必须有个分支是<code>coding-pages</code></p><p>其他没提的事情和上一篇是一样的.<br>最后执行<code>hexo d -g</code>,打完收工</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章&lt;a href=&quot;http://jackroyal.github.io/2015/11/25/how-to-solve-the-problem-that-github-blocks-the-baidu-spider/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解决 Github Pages 禁止百度爬虫的方法&lt;/a&gt;,提到了解决百度爬虫被github禁用掉的方法.&lt;br&gt;&lt;code&gt;把博客同时发布到github pages和gitcafe pages.然后使用dnspod设置域名解析,国内线路解析到gitcafe,国外线路解析到github.&lt;/code&gt;&lt;br&gt;然后今天去上gitcafe,偶然看到这个&lt;br&gt;&lt;img src=&quot;https://ww4.sinaimg.cn/large/692869a3gw1f1n79skvt3j20zl0m7k07.jpg&quot; alt=&quot;GitCafe 项目迁移至 Coding.net 公告&quot;&gt;&lt;br&gt;额(⊙o⊙)…,holly shit.不过没办法,人家都被收购了,我们只能改变策略了.&lt;br&gt;话说,两家都是做代码托管的,这也是顺(bao)应(tuan)潮(qu)流(nuan)咩?&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://bblove.me/categories/hexo/"/>
    
    
      <category term="github" scheme="https://bblove.me/tags/github/"/>
    
      <category term="hexo" scheme="https://bblove.me/tags/hexo/"/>
    
      <category term="baidu" scheme="https://bblove.me/tags/baidu/"/>
    
      <category term="git" scheme="https://bblove.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>php学习笔记(3.5)--关于引用赋值和一般赋值</title>
    <link href="https://bblove.me/2016/03/05/php-learn-note-3-5/"/>
    <id>https://bblove.me/2016/03/05/php-learn-note-3-5/</id>
    <published>2016-03-05T05:52:28.000Z</published>
    <updated>2018-05-30T01:57:59.316Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇提到了,对象赋值的时候有两种赋值方式,一种是直接<code>$a=$b</code>,第二种是引用赋值<code>$a=&amp;$b</code>.<br>不仅对象赋值的时候会有这两种情况,普通变量赋值也会有这两种情况,为了简单说明,我们先使用简单的普通变量来做说明.<br><a id="more"></a></p><h1 id="1-普通变量的结构"><a href="#1-普通变量的结构" class="headerlink" title="1 普通变量的结构"></a>1 普通变量的结构</h1><p>在PHP中,所有的变量都是用一个结构zval来保存的,zval大概的结构如下所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* Variable information */</span></span><br><span class="line">        zvalue_value value;             <span class="comment">/* value */</span></span><br><span class="line">        zend_uint refcount;</span><br><span class="line">        zend_uchar type;        <span class="comment">/* active type */</span></span><br><span class="line">        zend_uchar is_ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>我们这里主要用到的是两个变量,一个是refcount,即是引用计数,一个是is_ref,用来标记是否是引用.</p><h1 id="2-php环境的设置"><a href="#2-php环境的设置" class="headerlink" title="2 php环境的设置"></a>2 php环境的设置</h1><p>我们在实验过程中,需要去查看refcount和is_ref的变化,所以需要使用php的<br><code>xdebug_debug_zval</code>函数,你的环境可能默认没有开启这个配置,你需要修改<code>php.ini</code>文件开启这个配置.<br><img src="https://ww4.sinaimg.cn/large/692869a3gw1f1m1ximwj1j20wn098dj6.jpg" alt="修改php.ini文件"></p><h1 id="3-refcount和is-ref"><a href="#3-refcount和is-ref" class="headerlink" title="3 refcount和is_ref"></a>3 refcount和is_ref</h1><p>我们通常的赋值方式:一般赋值和引用赋值.</p><h1 id="3-1-一般赋值"><a href="#3-1-一般赋值" class="headerlink" title="3.1 一般赋值"></a>3.1 一般赋值</h1><p>当使用一般给新变量赋值的时候,php的内存策略,并不是重新申请一个新的空间,而是把原来的那个recount+1.比如下面的例子:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a=<span class="string">'aaa'</span>;<span class="comment">//此时$a的recount=1,ref=0</span></span><br><span class="line">$b=$a;<span class="comment">//赋值过后,$a的recount=2,ref=0,$b因为指向和$a一样,所以结果和$a一样</span></span><br><span class="line">xdebug_debug_zval(<span class="string">'a'</span>,<span class="string">'b'</span>);</span><br></pre></td></tr></table></figure></p><p>输出结果如下<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(refcount=<span class="number">2</span>, is_ref=<span class="number">0</span>),<span class="type">string</span> 'aaa' (length=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><h1 id="3-2-引用赋值"><a href="#3-2-引用赋值" class="headerlink" title="3.2 引用赋值"></a>3.2 引用赋值</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a=<span class="string">'aaa'</span>;<span class="comment">//此时$a的recount=1,ref=0</span></span><br><span class="line">$c=&amp;$a;<span class="comment">//赋值过后,$a的recount=2,ref=0,$b因为指向和$a一样,所以结果和$a一样</span></span><br><span class="line">xdebug_debug_zval(<span class="string">'a'</span>,<span class="string">'b'</span>);<span class="comment">//</span></span><br></pre></td></tr></table></figure><p>输出结果如下<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(refcount=<span class="number">2</span>, is_ref=<span class="number">1</span>),<span class="type">string</span> 'aaa' (length=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>由上面可知,也就是每次进行赋值的时候,refcount都会+1,如果是引用赋值,is_ref就会被置为一.</p><h1 id="3-3-两种赋值方式混合"><a href="#3-3-两种赋值方式混合" class="headerlink" title="3.3 两种赋值方式混合"></a>3.3 两种赋值方式混合</h1><p>那如果我们混合上面的两种赋值方式呢?比如下面的代码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$a=<span class="string">'aaa'</span>;</span><br><span class="line">$b=&amp;$a;</span><br><span class="line">$c=$a;</span><br><span class="line">xdebug_debug_zval(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></p><p>你猜输出结果是什么?<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">a</span>: (refcount=<span class="number">2</span>, is_ref=<span class="number">1</span>),<span class="keyword">string</span> <span class="string">'aaa'</span> (<span class="built_in">length</span>=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">b: (refcount=<span class="number">2</span>, is_ref=<span class="number">1</span>),<span class="keyword">string</span> <span class="string">'aaa'</span> (<span class="built_in">length</span>=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">c: (refcount=<span class="number">1</span>, is_ref=<span class="number">0</span>),<span class="keyword">string</span> <span class="string">'aaa'</span> (<span class="built_in">length</span>=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>为什么会这样呢?<br>我们一行一行的分析.</p><ol><li>首先第一行代码执行完以后,$a的结果应该是<code>(refcount=1, is_ref=0),string &#39;aaa&#39; (length=3)</code></li><li>第二行代码执行引用赋值,因为refcount=1,所以$a的refcount直接+1,is_ref变成1,输出即是`(refcount=2, is_ref=1),string ‘aaa’ </li><li>第三行代码执行一般赋值,那我们是不是再把refcount+1呢?不是的,因为此时的refcount&gt;1并且is_ref不为0,所以不能执行那个操作,而是直接把$a复制了另外一份,而不是修改$a的计数器.<br>所以,最后的输出结果,$c的refcount是1,因为它完全另外申请了一个副本</li></ol><p>我们把上面的代码换个位置<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$a=<span class="string">'aaa'</span>;</span><br><span class="line">$c=$a;</span><br><span class="line">$b=&amp;$a;</span><br><span class="line">xdebug_debug_zval(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></p><p>你再猜猜输出结果是什么?<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">a</span>: (refcount=<span class="number">2</span>, is_ref=<span class="number">1</span>),<span class="keyword">string</span> <span class="string">'aaa'</span> (<span class="built_in">length</span>=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">b: (refcount=<span class="number">2</span>, is_ref=<span class="number">1</span>),<span class="keyword">string</span> <span class="string">'aaa'</span> (<span class="built_in">length</span>=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">c: (refcount=<span class="number">1</span>, is_ref=<span class="number">0</span>),<span class="keyword">string</span> <span class="string">'aaa'</span> (<span class="built_in">length</span>=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>咦?结果是一样的哈?<br>对的,结果是一样的,不过执行的过程却是不同的,我们再来一行一行的分析下</p><ol><li>首先第一行代码执行完以后,$a的结果应该是<code>(refcount=1, is_ref=0),string &#39;aaa&#39; (length=3)</code></li><li>第二行代码执行一般赋值,同理,因为refcount=1,所以$a的refcount直接+1,is_ref不变,输出即是`(refcount=2, is_ref=0),string ‘aaa’ </li><li>第三行代码执行引用赋值,跟上面一样,因为refcount=2了,所以不能直接进行计数器+1,我们先检查is_ref,发现是0.这时,php首先做一个分离操作,也就是把上面一般赋值的那个值,给分离出去,分离后,$a的refcount减去1,也就是$c独立了,那么此时$a和$c的输出结果应该是<code>(refcount=1, is_ref=0),string &#39;aaa&#39; (length=3)</code>.在分离操作完成后,再做引用赋值的问题,这时候就简单了,因为$a的refcount是1,所以我们直接refcount+1,is_ref=1就搞定</li><li>最后输出结果就是上面的结果了</li></ol><p><strong>php把上面的过程叫做写时复制(copy on write),也就是说,一般赋值$c=$a时候,php并不是立即去申请一个新的变量空间.,而是等到执行引用赋值或者其他写操作的时候(比如这个时候修改$c的值),php才会去开辟一个新的空间给赋值后的变量,也就是分离操作.</strong></p><h1 id="4-推广到对象"><a href="#4-推广到对象" class="headerlink" title="4 推广到对象"></a>4 推广到对象</h1><p>上面普通变量的赋值,应该说清楚了哈.<br>其实对象的赋值和普通变量赋值是同一个道理.下面直接贴代码,不在赘述<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $aa=<span class="string">'我是类属性'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$a=<span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'刚执行完$a定义&lt;br&gt;'</span>;</span><br><span class="line">xdebug_debug_zval(<span class="string">'a'</span>);</span><br><span class="line">$b=$a;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'刚执行完$b赋值&lt;br&gt;'</span>;</span><br><span class="line">xdebug_debug_zval(<span class="string">'b'</span>);</span><br><span class="line">$c=&amp;$a;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'刚执行完$c赋值&lt;br&gt;'</span>;</span><br><span class="line">xdebug_debug_zval(<span class="string">'c'</span>);</span><br><span class="line">$d=$b;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'刚执行完$d赋值&lt;br&gt;'</span>;</span><br><span class="line">xdebug_debug_zval(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>);</span><br></pre></td></tr></table></figure></p><p>输出结果如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">刚执行完<span class="variable">$a</span>定义</span><br><span class="line"><span class="selector-tag">a</span>: </span><br><span class="line">(refcount=<span class="number">1</span>, is_ref=<span class="number">0</span>),</span><br><span class="line"><span class="function"><span class="title">object</span><span class="params">(A)</span></span>[<span class="number">1</span>]</span><br><span class="line">  public <span class="string">'aa'</span> =&gt; (refcount=<span class="number">1</span>, is_ref=<span class="number">0</span>),string <span class="string">'我是类属性'</span> (length=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">刚执行完<span class="variable">$b</span>赋值</span><br><span class="line"><span class="selector-tag">b</span>: </span><br><span class="line">(refcount=<span class="number">2</span>, is_ref=<span class="number">0</span>),</span><br><span class="line"><span class="function"><span class="title">object</span><span class="params">(A)</span></span>[<span class="number">1</span>]</span><br><span class="line">  public <span class="string">'aa'</span> =&gt; (refcount=<span class="number">1</span>, is_ref=<span class="number">0</span>),string <span class="string">'我是类属性'</span> (length=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">刚执行完<span class="variable">$c</span>赋值</span><br><span class="line">c: </span><br><span class="line">(refcount=<span class="number">2</span>, is_ref=<span class="number">1</span>),</span><br><span class="line"><span class="function"><span class="title">object</span><span class="params">(A)</span></span>[<span class="number">1</span>]</span><br><span class="line">  public <span class="string">'aa'</span> =&gt; (refcount=<span class="number">1</span>, is_ref=<span class="number">0</span>),string <span class="string">'我是类属性'</span> (length=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">刚执行完<span class="variable">$d</span>赋值</span><br><span class="line"><span class="selector-tag">a</span>: </span><br><span class="line">(refcount=<span class="number">2</span>, is_ref=<span class="number">1</span>),</span><br><span class="line"><span class="function"><span class="title">object</span><span class="params">(A)</span></span>[<span class="number">1</span>]</span><br><span class="line">  public <span class="string">'aa'</span> =&gt; (refcount=<span class="number">1</span>, is_ref=<span class="number">0</span>),string <span class="string">'我是类属性'</span> (length=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">b</span>: </span><br><span class="line">(refcount=<span class="number">2</span>, is_ref=<span class="number">0</span>),</span><br><span class="line"><span class="function"><span class="title">object</span><span class="params">(A)</span></span>[<span class="number">1</span>]</span><br><span class="line">  public <span class="string">'aa'</span> =&gt; (refcount=<span class="number">1</span>, is_ref=<span class="number">0</span>),string <span class="string">'我是类属性'</span> (length=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">c: </span><br><span class="line">(refcount=<span class="number">2</span>, is_ref=<span class="number">1</span>),</span><br><span class="line"><span class="function"><span class="title">object</span><span class="params">(A)</span></span>[<span class="number">1</span>]</span><br><span class="line">  public <span class="string">'aa'</span> =&gt; (refcount=<span class="number">1</span>, is_ref=<span class="number">0</span>),string <span class="string">'我是类属性'</span> (length=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">d: </span><br><span class="line">(refcount=<span class="number">2</span>, is_ref=<span class="number">0</span>),</span><br><span class="line"><span class="function"><span class="title">object</span><span class="params">(A)</span></span>[<span class="number">1</span>]</span><br><span class="line">  public <span class="string">'aa'</span> =&gt; (refcount=<span class="number">1</span>, is_ref=<span class="number">0</span>),string <span class="string">'我是类属性'</span> (length=<span class="number">15</span>)</span><br></pre></td></tr></table></figure></p><h1 id="5-关于debug-zval-dump函数"><a href="#5-关于debug-zval-dump函数" class="headerlink" title="5 关于debug_zval_dump函数"></a>5 关于debug_zval_dump函数</h1><p>php中还有个关于计数的函数叫做<code>debug_zval_dump</code>,它只返回refcount,不过这个函数好奇葩,输出的数据有时候跟想的都不一样.<br>比如:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a=<span class="string">'aaa'</span>;</span><br><span class="line">$b=$a;</span><br><span class="line">debug_zval_dump($a);<span class="comment">//输出3</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>原因是:执行<code>debug_zval_dump</code>相当于执行了一次一般赋值操作,所以,refcount会再加1<br>再比如<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a=<span class="string">'aaa'</span>;</span><br><span class="line">$c=$a;</span><br><span class="line">$c=<span class="string">'bbb'</span>;</span><br><span class="line">debug_zval_dump($a,$c);<span class="comment">//输出refcount=2,refcount=2</span></span><br><span class="line">xdebug_debug_zval(<span class="string">'a'</span>,<span class="string">'c'</span>);<span class="comment">//两个值完全相同,都是refcount=1, is_ref=0),string 'bbb' (length=3)</span></span><br></pre></td></tr></table></figure></p><p>额,这是不是很奇葩?再来一波<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a=<span class="string">'aaa'</span>;</span><br><span class="line">$b=&amp;$a;</span><br><span class="line">$c=$a;</span><br><span class="line">debug_zval_dump($a,$b,$c);<span class="comment">//refcount分别是1,1,2</span></span><br><span class="line">xdebug_debug_zval(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);<span class="comment">//refcount和is_ref分别是(2,1),(2,1),(1,0)</span></span><br></pre></td></tr></table></figure></p><p>这是什么鬼?我表示都看不懂<br>稍微总结了下,<code>debug_zval_dump</code>这个函数,如果只是一般赋值,那么还比较正常,赋值一次就是refcount+1操作,最后调用<code>debug_zval_dump</code>的再+1就好了<br>但是一旦涉及到引用赋值,这货就全变成1了,(引用赋值不+1就算了,说好的调用<code>debug_zval_dump</code>的+1呢?被狗吃了?),完全搞不懂是在搞啥,还是<code>xdebug_debug_zval</code>函数好.<br>打完收工<br>ps:其实我在知乎提了个问题,不过没人回答还<a href="http://www.zhihu.com/question/41044486" target="_blank" rel="noopener">debug_zval_dump的计数问题?</a></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>1 <a href="http://www.laruence.com/2008/09/19/520.html" target="_blank" rel="noopener">鸟哥的博客–深入理解PHP原理之变量分离/引用</a><br>2 <a href="http://weizhifeng.net/write-php-extension-part2-2.html" target="_blank" rel="noopener">PHP扩展编写第二步：参数，数组，以及ZVAL「续」</a><br>3 <a href="http://php.net/manual/zh/function.debug-zval-dump.php" target="_blank" rel="noopener">php官方文档–debug_zval_dump函数</a><br>4 <a href="https://derickrethans.nl/talks/phparch-php-variables-article.pdf" target="_blank" rel="noopener">英文文档–php变量</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇提到了,对象赋值的时候有两种赋值方式,一种是直接&lt;code&gt;$a=$b&lt;/code&gt;,第二种是引用赋值&lt;code&gt;$a=&amp;amp;$b&lt;/code&gt;.&lt;br&gt;不仅对象赋值的时候会有这两种情况,普通变量赋值也会有这两种情况,为了简单说明,我们先使用简单的普通变量来做说明.&lt;br&gt;
    
    </summary>
    
      <category term="php学习笔记" scheme="https://bblove.me/categories/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="php" scheme="https://bblove.me/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>php学习笔记(3)</title>
    <link href="https://bblove.me/2016/03/04/php-learn-note-3/"/>
    <id>https://bblove.me/2016/03/04/php-learn-note-3/</id>
    <published>2016-03-04T02:06:40.000Z</published>
    <updated>2018-07-08T11:45:18.741Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始学习类和面向对象了.<br><a id="more"></a></p><h1 id="1-对象实例化"><a href="#1-对象实例化" class="headerlink" title="1 对象实例化"></a>1 对象实例化</h1><p>在实例化对象的时候,必须使用<code>new</code>关键字.如果该类属于一个名字空间,则必须使用其完整名称.<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$instance = <span class="keyword">new</span> SimpleClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样做：</span></span><br><span class="line">$className = <span class="string">'Foo'</span>;</span><br><span class="line">$instance = <span class="keyword">new</span> $className(); <span class="comment">// Foo()</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="1-1-对象赋值"><a href="#1-1-对象赋值" class="headerlink" title="1.1 对象赋值"></a>1.1 对象赋值</h2><p>我们创建一个对象的实例后,后面进行赋值的时候有两种赋值.<br>第一种是直接<code>$a=$b</code>,第二种是引用赋值<code>$a=&amp;$b</code>.<br>这两个有什么区别呢?问题可深了,所以我决定单独写一篇文章来说这个问题.<br><a href="http://jackroyal.github.io/2016/03/05/php-learn-note-3-5/" target="_blank" rel="noopener">php学习笔记(3.5)–关于引用赋值和一般赋值</a></p><h2 id="1-2-extends关键字"><a href="#1-2-extends关键字" class="headerlink" title="1.2 extends关键字"></a>1.2 extends关键字</h2><p>一个类可以在声明中用 extends 关键字继承另一个类的方法和属性.<em>PHP不支持多重继承,一个类只能继承一个基类.</em><br>被继承的方法和属性可以通过用同样的名字重新声明被覆盖.但是如果父类定义方法时使用了 final,则该方法不可被覆盖.可以通过 parent:: 来访问被覆盖的方法或属性.<br>当覆盖方法时,参数必须保持一致否则 PHP 将发出 E_STRICT 级别的错误信息.但构造函数例外,构造函数可在被覆盖时使用不同的参数.</p><h1 id="2-属性"><a href="#2-属性" class="headerlink" title="2 属性"></a>2 属性</h1><p>类的变量成员叫做属性,属性声明是由关键字public,protected或者private开头,然后跟一个普通的变量声明来组成,尤其需要注意的是,属性的变量可以初始化,但是初始化值必须是常数,也就是不能有表达式比如下面的就是错误的:<br><code>public $var1 = &#39;hello &#39; . &#39;world&#39;;</code>,<code>public $var3 = 1+2;</code>.<br>在php5.3之后,nowdocs的结构也是可行的.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天开始学习类和面向对象了.&lt;br&gt;
    
    </summary>
    
      <category term="php学习笔记" scheme="https://bblove.me/categories/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="php" scheme="https://bblove.me/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>php学习笔记(2)</title>
    <link href="https://bblove.me/2016/02/25/php-learn-note-2/"/>
    <id>https://bblove.me/2016/02/25/php-learn-note-2/</id>
    <published>2016-02-25T06:36:20.000Z</published>
    <updated>2018-05-30T01:57:59.320Z</updated>
    
    <content type="html"><![CDATA[<p>今天看的是最基础的变量.<br><a id="more"></a></p><h1 id="1-php变量"><a href="#1-php变量" class="headerlink" title="1 php变量"></a>1 php变量</h1><p>和其他语言类似,php中一个有效的变量名由字母或者下划线开头,后面跟上任意数量的字母,数字,或者下划线.按照正常的正则表达式,它将被表述为：’[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*’.<br>赋值的时候,变量默认总是<code>传值赋值</code>.<br>在php中也可以用<code>引用赋值</code>,也就是改动新的变量也会因想到原始变量,反之亦然.<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$foo = <span class="string">'Bob'</span>;              <span class="comment">// 将 'Bob' 赋给 $foo</span></span><br><span class="line">$bar = &amp;$foo;              <span class="comment">// 通过 $bar 引用 $foo</span></span><br><span class="line">$bar = <span class="string">"My name is $bar"</span>;  <span class="comment">// 修改 $bar 变量</span></span><br><span class="line"><span class="keyword">echo</span> $bar;</span><br><span class="line"><span class="keyword">echo</span> $foo;                 <span class="comment">// $foo 的值也被修改</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>ps:只有有名字的变量才可以使用引用赋值,也就是无法对一个表达式使用引用赋值.<br>使用<code>isset()</code>来检测变量是否被初始化.</p><h1 id="2-预定义变量"><a href="#2-预定义变量" class="headerlink" title="2 预定义变量"></a>2 预定义变量</h1><p>php会自动用下划线来替换所有的传入变量中的<code>.</code>号,例子如下所示<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">example.com/page.php?chuck.norris=nevercries</span><br><span class="line"></span><br><span class="line">you can not reference them by the name used in the URI:</span><br><span class="line"><span class="comment">//INCORRECT</span></span><br><span class="line"><span class="keyword">echo</span> $_GET[<span class="string">'chuck.norris'</span>];</span><br><span class="line"></span><br><span class="line">instead you must <span class="keyword">use</span>:</span><br><span class="line">//<span class="title">CORRECT</span></span><br><span class="line"><span class="title">echo</span> $<span class="title">_GET</span>['<span class="title">chuck_norris</span>'];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="3-变量范围"><a href="#3-变量范围" class="headerlink" title="3 变量范围"></a>3 变量范围</h1><p>变量的范围即它定义的上下文背景（也就是它的生效范围）.大部分的 PHP 变量只有一个单独的范围.这个单独的范围跨度同样包含了 include 和 require 引入的文件.例如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">include</span> <span class="string">'b.inc'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里变量 $a 将会在包含文件 b.inc 中生效.但是,在用户自定义函数中,一个局部函数范围将被引入.任何用于函数内部的变量按缺省情况将被限制在局部函数范围内.例如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="number">1</span>; <span class="comment">/* global scope */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> $a; <span class="comment">/* reference to local scope variable */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个脚本不会有任何输出,因为 <code>echo</code>语句引用了一个局部版本的变量$a,而且在这个范围内,它并没有被赋值.你可能注意到 PHP 的全局变量和 C 语言有一点点不同,在 C 语言中,全局变量在函数中自动生效,除非被局部变量覆盖.这可能引起一些问题,有些人可能不小心就改变了一个全局变量.PHP 中全局变量在函数中使用时必须声明为 <code>global</code>.<br>PS:此处需要注意的是,php不存在类似C和java的块级作用域.比如你在循环中定义的一个变量,在循环外还是可以访问的<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span>($j=<span class="number">0</span>; $j&lt;<span class="number">3</span>; $j++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>($j == <span class="number">1</span>)</span><br><span class="line">        $a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $a;<span class="comment">//此处将会输出4</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="3-2-静态变量"><a href="#3-2-静态变量" class="headerlink" title="3.2 静态变量"></a>3.2 静态变量</h2><p>php还支持静态变量,静态变量<code>仅在局部函数域中</code>存在,但当程序执行离开此作用域时,其值并不丢失.<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">echo</span> $a;</span><br><span class="line">    $a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="4-来自PHP之外的变量"><a href="#4-来自PHP之外的变量" class="headerlink" title="4 来自PHP之外的变量"></a>4 来自PHP之外的变量</h1><p>此处主要指的是通过表单提交的变量,从cookie读取的变量</p><h2 id="4-1-图片提交表单"><a href="#4-1-图片提交表单" class="headerlink" title="4.1 图片提交表单"></a>4.1 图片提交表单</h2><p>除了常用的通过表单按钮提交表单,我们还可以使用图片的形式提交表单,代码如下:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"image"</span> src=<span class="string">"image.gif"</span> name=<span class="string">"sub"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>这样在后端接收的时候,还会受到一个叫做<code>sub_x</code>和<code>sub_y</code>的变量,它包含了用户点击图片的坐标.此处如果你不定义<code>name</code>为<code>sub</code>,那么后端接收变量就是<code>x</code>和<code>y</code>.</p><h1 id="4-2-PHP自动转换变量名"><a href="#4-2-PHP自动转换变量名" class="headerlink" title="4.2 PHP自动转换变量名"></a>4.2 PHP自动转换变量名</h1><p>当我们通过表单提交变量的时候,如果表单项的名称包含空格,点号,左中括号,php就会自动把他们转换成下划线.<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> name= <span class="string">"userName.a"</span>/&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> name= <span class="string">"passWor[d"</span>/&gt;</span><br><span class="line"><span class="comment">//输出[userName_a] =&gt; [passWor_d] =&gt; </span></span><br><span class="line"><span class="comment">//都被转化成下划线了</span></span><br></pre></td></tr></table></figure></p><p>chr(32) ( ) (space)<br>chr(46) (.) (dot)<br>chr(91) ([) (open square bracket)</p><p>ps:ascll码值在128-159的字符是合法字符,所以并不会被转义成下划线</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看的是最基础的变量.&lt;br&gt;
    
    </summary>
    
      <category term="php学习笔记" scheme="https://bblove.me/categories/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="php" scheme="https://bblove.me/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>digitalocean下ubuntu切换内核,使用锐速</title>
    <link href="https://bblove.me/2016/01/28/digitalocean-switch-kernel/"/>
    <id>https://bblove.me/2016/01/28/digitalocean-switch-kernel/</id>
    <published>2016-01-28T08:59:10.000Z</published>
    <updated>2018-05-30T01:57:59.311Z</updated>
    
    <content type="html"><![CDATA[<p>最近在网上看到,锐速可以用来给服务器加速,然后有人用这个软件来给翻墙服务器加速,据说效果还不错,今天就折腾一下.<br><a id="more"></a><br>我去锐速官网注册了账号,可惜,在官方支持的linux版本中并没有我这个内核版本.我用的是<code>3.13.0-37-generic</code>的<code>32</code>位版本,锐速官网并没有支持.<code>32</code>位版本支持的相对较少,支持的最新版本是<code>3.13.0-29-generic</code>.<br><img src="https://ww3.sinaimg.cn/large/692869a3gw1f0fbk1mp65j213c0ozdru.jpg" alt="锐速官网linux支持列表"><br>所以没办法,只能把我的<code>ubuntu</code>降级回去,还是小折腾了一下.下面就来说下降级</p><h1 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h1><p>digitalocean的云服务器<br>Linux OS:   Ubuntu<br>Version:    14.04<br>Kernel:     3.13.0-37-generic<br>Bits:       32-bit</p><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><p>ssh登录服务器,然后安装新内核,blablabla…<br>你要是这样想就跟我一样,想错了.<br>因为我们使用的是<code>digitalocean</code>的云服务器,不是普通的个人单机,所以那套方法不顶用,我照着那个方法,安装了新的内核,然后更新<code>grub</code>,怎么弄都没用,最后才找到答案.<br><strong>争取的做法:</strong><br>1 登录你的<code>digitalocean</code>控制台<br>2 点击<code>setting-&gt;kernel</code>,效果如下图<br><img src="https://ww2.sinaimg.cn/large/692869a3gw1f0fbvo209sj20vd0kkdkf.jpg" alt="控制台的kernel页面"><br>3 点击下拉列表,找到你要的<code>kernel</code>,比如我要的是<code>Ubuntu 14.04 x32 vmlinuz-3.13.0-29-generic</code>,然后点击<code>change</code>,等一会儿,页面会自动刷新,内核更新就成功了<br>4 重要的一步,我就是这步有点问题,又浪费了点时间.更新完内核,我们发现自己的服务器查看内核的时候并没有变化,我们首先想到的是重启服务器.我们直接在终端<code>sudo reboot</code>.但是启动以后,你会发现还是没有变化,什么鬼?<br>真正的答案是,我们现在终端关机,也即是执行<code>sudo poweroff</code>,先关机.然后我们在控制台的power选项卡中,有个<code>power on</code>的按钮,我们启动服务器,就发现内核已经更新了.<br>ok 打完收工</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>1 <a href="https://www.digitalocean.com/community/tutorials/how-to-upgrade-ubuntu-12-04-lts-to-ubuntu-14-04-lts" target="_blank" rel="noopener">How to Upgrade Ubuntu 12.04 LTS to Ubuntu 14.04 LTS</a><br>2 <a href="https://www.digitalocean.com/community/tutorials/how-to-update-a-digitalocean-server-s-kernel" target="_blank" rel="noopener">How To Update a DigitalOcean Server’s Kernel</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在网上看到,锐速可以用来给服务器加速,然后有人用这个软件来给翻墙服务器加速,据说效果还不错,今天就折腾一下.&lt;br&gt;
    
    </summary>
    
      <category term="服务器" scheme="https://bblove.me/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="https://bblove.me/tags/Linux/"/>
    
      <category term="digitalocean" scheme="https://bblove.me/tags/digitalocean/"/>
    
  </entry>
  
  <entry>
    <title>php学习笔记(1)</title>
    <link href="https://bblove.me/2015/12/10/php-learn-note-1/"/>
    <id>https://bblove.me/2015/12/10/php-learn-note-1/</id>
    <published>2015-12-10T07:46:03.000Z</published>
    <updated>2018-05-30T01:57:59.323Z</updated>
    
    <content type="html"><![CDATA[<p>php文档学习笔记,正式开始连载了哈,终于开始学习了.<br><a id="more"></a></p><h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p>要明确地将一个值转换成 boolean，用 (bool) 或者 (boolean) 来强制转换。但是很多情况下不需要用强制转换，因为当运算符，函数或者流程控制结构需要一个 boolean 参数时，该值会被自动转换。<br>当转换为 boolean 时，以下值被认为是 FALSE：</p><ul><li>布尔值 <strong>FALSE</strong> 本身</li><li>整型值 <strong>0</strong>（零）</li><li>浮点型值 <strong>0.0</strong>（零）</li><li>空字符串，以及字符串 <strong>“0”</strong></li><li>不包括任何元素的数组</li><li>不包括任何成员变量的对象（仅 PHP 4.0 适用）</li><li>特殊类型 <strong>NULL</strong>（包括尚未赋值的变量）</li><li>从空标记生成的 <strong>SimpleXML</strong> 对象</li><li>所有其它值都被认为是 <strong>TRUE</strong>（包括任何资源）。</li></ul><p><strong>PS:</strong><br>-1 和其它非零值（不论正负）一样，被认为是 <strong>TRUE</strong>！<br>接下来我们可以试试,自己写一些常见的布尔值<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var_dump((bool)<span class="string">'0'</span>);        <span class="comment">//false</span></span><br><span class="line">var_dump((bool)<span class="string">'0.0'</span>);      <span class="comment">//true</span></span><br><span class="line">var_dump((bool)<span class="string">'0.1'</span>);      <span class="comment">//true</span></span><br><span class="line">var_dump((bool)<span class="keyword">array</span>());    <span class="comment">//false</span></span><br><span class="line">var_dump((bool)<span class="string">"false"</span>);    <span class="comment">//true,因为这个字符串不为空,所以为true</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;php文档学习笔记,正式开始连载了哈,终于开始学习了.&lt;br&gt;
    
    </summary>
    
      <category term="php学习笔记" scheme="https://bblove.me/categories/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="php" scheme="https://bblove.me/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>那些年,我们玩过的离线安装</title>
    <link href="https://bblove.me/2015/11/26/offline-install/"/>
    <id>https://bblove.me/2015/11/26/offline-install/</id>
    <published>2015-11-26T05:34:46.000Z</published>
    <updated>2018-05-30T01:57:59.318Z</updated>
    
    <content type="html"><![CDATA[<p>由于有些软件,都是下载一个安装器,然后在线安装,由于网速的原因,这种方式一旦失败,就只能重新安装,所以很坑,就找了些离线安装的方法<br><a id="more"></a></p><h1 id="1-Adobe-reader离线安装"><a href="#1-Adobe-reader离线安装" class="headerlink" title="1 Adobe reader离线安装"></a>1 Adobe reader离线安装</h1><p>下载离线安装版adobe reader<br><a href="https://get.adobe.com/cn/reader/enterprise/" target="_blank" rel="noopener">https://get.adobe.com/cn/reader/enterprise/</a></p><h1 id="2-chrome离线安装"><a href="#2-chrome离线安装" class="headerlink" title="2 chrome离线安装"></a>2 chrome离线安装</h1><p>Windows平台：</p><p>Chrome 离线安装包（仅 Windows 可用）：<br>最新稳定版（Stable Channel）：<br><a href="http://www.google.com/chrome/eula.html?hl=zh-CN&amp;standalone=1" target="_blank" rel="noopener">http://www.google.com/chrome/eula.html?hl=zh-CN&amp;standalone=1</a></p><p>最新测试版（Beta Channel）：<br><a href="http://www.google.com/chrome/eula.html?hl=zh-CN&amp;standalone=1&amp;extra=betachannel" target="_blank" rel="noopener">http://www.google.com/chrome/eula.html?hl=zh-CN&amp;standalone=1&amp;extra=betachannel</a></p><p>最新开发版（Dev Channel）：<br><a href="http://www.google.com/chrome/eula.html?hl=zh-CN&amp;standalone=1&amp;extra=devchannel" target="_blank" rel="noopener">http://www.google.com/chrome/eula.html?hl=zh-CN&amp;standalone=1&amp;extra=devchannel</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于有些软件,都是下载一个安装器,然后在线安装,由于网速的原因,这种方式一旦失败,就只能重新安装,所以很坑,就找了些离线安装的方法&lt;br&gt;
    
    </summary>
    
      <category term="软件安装与技巧" scheme="https://bblove.me/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="chrome" scheme="https://bblove.me/tags/chrome/"/>
    
      <category term="离线安装" scheme="https://bblove.me/tags/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/"/>
    
      <category term="flash" scheme="https://bblove.me/tags/flash/"/>
    
  </entry>
  
  <entry>
    <title>解决 Github Pages 禁止百度爬虫的方法</title>
    <link href="https://bblove.me/2015/11/25/how-to-solve-the-problem-that-github-blocks-the-baidu-spider/"/>
    <id>https://bblove.me/2015/11/25/how-to-solve-the-problem-that-github-blocks-the-baidu-spider/</id>
    <published>2015-11-25T03:06:50.000Z</published>
    <updated>2018-05-30T01:57:59.336Z</updated>
    
    <content type="html"><![CDATA[<p><em>update</em>:因为gitcafe在5月31号就关闭了,所以要将文章中的gitcafe换掉,我重新写了一篇,在这里<a href="http://jackroyal.github.io/2016/03/06/migrate-pages-from-gitcafe-to-coding/" target="_blank" rel="noopener">解决 Github Pages 禁止百度爬虫的方法2–从gitcafe迁移到coding.net</a></p><p>最近,我的github student package里面送的一个namecheap域名终于下来了.That is to say:我终于有自己的域名了,这就是我的域名<a href="http://bblove.me">http://bblove.me</a>,欢迎来访.<br><a id="more"></a><br>有域名以后,就在想办法解决百度爬虫的问题.<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hi Jackroyal,</span><br><span class="line"></span><br><span class="line">We are currently blocking the Baidu<span class="built_in"> user </span>agent <span class="keyword">from</span> crawling GitHub Pages</span><br><span class="line">sites <span class="keyword">in</span> response <span class="keyword">to</span> this<span class="built_in"> user </span>agent being responsible <span class="keyword">for</span> an excessive amount</span><br><span class="line">of requests, which was causing availability issues <span class="keyword">for</span> other GitHub customers.</span><br><span class="line">This is unlikely <span class="keyword">to</span> change any time soon, so <span class="keyword">if</span> you need the Baidu<span class="built_in"> user </span>agent</span><br><span class="line"><span class="keyword">to</span> be able <span class="keyword">to</span> crawl your site you will need <span class="keyword">to</span> host it elsewhere.</span><br><span class="line"></span><br><span class="line">Cheers,</span><br><span class="line">Scott</span><br></pre></td></tr></table></figure></p><p>这是我之前跟github反映百度spider无法抓取我的github pages,他们给我的回复邮件.也就是说他们把百度spider给禁掉了,桑不起.<br>直接说解决方法:<br><code>把博客同时发布到github pages和gitcafe pages.然后使用dnspod设置域名解析,国内线路解析到gitcafe,国外线路解析到github.</code></p><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><h1 id="1-准备条件"><a href="#1-准备条件" class="headerlink" title="1 准备条件"></a>1 准备条件</h1><p>一共需要一下这几个东西:</p><ul><li>一个github账户</li><li>一个gitcafe账户</li><li>一个dnspod账号</li><li>一个域名</li><li>github for windows(或者git客户端也行)<br>没了,就这么多就行.</li></ul><h1 id="2-初始操作"><a href="#2-初始操作" class="headerlink" title="2 初始操作"></a>2 初始操作</h1><p>我们在github和gitcafe上面把自己的博客搭建起来,首先要建仓库.<br><strong>github</strong>:<br>    首先登录你的github,然后新建一个公共仓库,仓库名是你的用户名加上<code>yourname.github.io</code>,如下图所示,我的用户名是<code>Jackroyal</code><br>    <img src="https://ww1.sinaimg.cn/large/692869a3gw1eye6fpc3w8j20ue0idjv0.jpg" alt="github新建仓库"></p><p><strong>gitcafe</strong>:<br>    操作方法差不多,不过有点区别是,gitcafe新建的公开项目,是和用户名一致的,比如我的用户名是<code>Jackroyal</code>,那我新建的仓库名就是<code>Jackroyal</code></p><p>仓库新建成功后,你获取到的链接应该是类似下面的<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/Jackroyal/</span>Jackroyal.github.io.git</span><br><span class="line">https:<span class="regexp">//gi</span>tcafe.com<span class="regexp">/Jackroyal/</span>Jackroyal.git</span><br></pre></td></tr></table></figure></p><p>这就是你的两个page对应的仓库.</p><h1 id="3-搭建博客"><a href="#3-搭建博客" class="headerlink" title="3 搭建博客"></a>3 搭建博客</h1><h2 id="3-1-搭建github-pages"><a href="#3-1-搭建github-pages" class="headerlink" title="3.1 搭建github pages"></a>3.1 搭建github pages</h2><p>当你的仓库建好了,我们就开始搭建博客,因为之前的博客有写,具体过程就不赘述<a href="http://jackroyal.github.io/2015/06/16/hexo-3-0-update/" target="_blank" rel="noopener">安装和配置hexo 3.0</a>.</p><p>按照上面的教程一步一步,就能搭建好博客,然后你就可以访问你的gihub pages了,访问链接就是<code>http://yourname.github.io</code>,比如我的即使<code>http://jackroyal.github.io</code>.<br>现在我们开始搭建gitcafe上面的pages了.由于hexo现在已经支持多发布,所以很简单,我们只需要配置deploy的信息,修改<code>_config.yml</code>.添加gitcafe的仓库信息.我的修改结果如下,<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">- <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="string">'https://github.com/Jackroyal/Jackroyal.github.io.git'</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br><span class="line">- <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="string">'https://gitcafe.com/Jackroyal/Jackroyal.git'</span></span><br><span class="line">  <span class="attribute">branch</span>: gitcafe-pages</span><br></pre></td></tr></table></figure></p><p>尤其需要注意的是,两个的branch是不同的,<code>github</code>默认分支是<code>master</code>,<code>gitcafe</code>默认分支是<code>gitcafe-pages</code>.</p><h2 id="3-2-添加gitcafe的ssh公钥"><a href="#3-2-添加gitcafe的ssh公钥" class="headerlink" title="3.2 添加gitcafe的ssh公钥"></a>3.2 添加gitcafe的ssh公钥</h2><p>由于我使用的是<code>github for windows</code>的终端界面,也就是github官方提供的客户端,他的好处是,我使用github的时候,不需要配置ssh公钥,密钥之类的东西.如果你用的不是这个,用的是git的客户端,那就需要配置ssh公钥,参考这里<a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="noopener">github配置公钥</a>.<br>对的,你猜到了,我们现在需要配置gitcafe的ssh公钥,因为<code>github for windows</code>会自动帮我们上传公钥,gitcafe就只能手动了.</p><h3 id="3-2-1-查看本地公钥"><a href="#3-2-1-查看本地公钥" class="headerlink" title="3.2.1 查看本地公钥"></a>3.2.1 查看本地公钥</h3><p>我们打开你使用的git终端,首先切回用户目录,然后进入<code>.ssh</code>目录,里面就有公钥和私钥,如下图所示<br><img src="https://ww2.sinaimg.cn/large/692869a3gw1eye75djqo9j20gj09475k.jpg" alt="使用git客户端查看ssh公钥私钥"><br><img src="https://ww2.sinaimg.cn/large/692869a3gw1eye78gs0hvj20it0ca761.jpg" alt="使用github for windows查看ssh公钥私钥"><br>我们就是要读取后缀是<code>.pub</code>的那个文件,比如我的读取命令就是<code>cat github_rsa.pub</code>,执行结果如下<br><img src="https://ww3.sinaimg.cn/large/692869a3gw1eye7c2xpavj20if06dt9w.jpg" alt="查看公钥"></p><h3 id="3-2-2-添加公钥到gitcafe"><a href="#3-2-2-添加公钥到gitcafe" class="headerlink" title="3.2.2 添加公钥到gitcafe"></a>3.2.2 添加公钥到gitcafe</h3><p>我们在<a href="https://gitcafe.com/account/public_keys" target="_blank" rel="noopener">这里</a>来设置gitcafe的公钥.<br><em>PS:需要注意的是,公钥后面的chen@chen-pc是不需要的,我的带上以后,gitcafe说是公钥非法,不过不怕,gitcafe会帮你正确格式化</em><br><img src="https://ww1.sinaimg.cn/large/692869a3gw1eye7h4ha7dj20v105n0ve.jpg" alt="正确的ssh格式"><br>反正就是把公钥加上去,就ok了</p><h2 id="3-4-同步博客到gitcafe"><a href="#3-4-同步博客到gitcafe" class="headerlink" title="3.4 同步博客到gitcafe"></a>3.4 同步博客到gitcafe</h2><p>上面的配置好了以后,我们就可以把博客内容同步到gitcafe了,方法很简单,执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></p><p>然后就可以啦.</p><h1 id="4-配置域名"><a href="#4-配置域名" class="headerlink" title="4 配置域名"></a>4 配置域名</h1><p>首先你得有个域名,像我一样,哈哈.</p><h2 id="4-1-修改域名注册的解析服务器"><a href="#4-1-修改域名注册的解析服务器" class="headerlink" title="4.1 修改域名注册的解析服务器"></a>4.1 修改域名注册的解析服务器</h2><p>我们在要把域名解析服务,设置到dnspod,因为他是国内的,而且服务很好.我们登录自己的域名管理后台,选择对应的域名进行管理,然后找到<code>nameservers</code>的设置,如图所示<br><img src="https://ww3.sinaimg.cn/large/692869a3gw1eye7orkymjj210j0i7tde.jpg" alt="修改nameservers的设置"><br>修改的值是<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1g1ns1<span class="selector-class">.dnspod</span><span class="selector-class">.net</span></span><br><span class="line">f1g1ns2<span class="selector-class">.dnspod</span><span class="selector-class">.net</span></span><br></pre></td></tr></table></figure></p><p>常见的域名注册商修改到dnspod,官方提供了教程,看<a href="https://support.dnspod.cn/Kb/guide/" target="_blank" rel="noopener">这里</a>-<br>改完以后可能要等一段时间才能生效,最多72小时<br>ok,改完以后,这边就完了,我们登录dnspod</p><h2 id="4-2-修改dnspod解析记录"><a href="#4-2-修改dnspod解析记录" class="headerlink" title="4.2 修改dnspod解析记录"></a>4.2 修改dnspod解析记录</h2><p>我们登录dnspod,然后添加域名<br>如果4.1中的设置生效了,你的域名就会添加成功了,我们直接进行下一步,修改解析记录,上图<br><img src="https://ww2.sinaimg.cn/large/692869a3gw1eye9mfkri4j20mt0efad6.jpg" alt="dns解析记录"><br>我们一共添加了5条记录,其中一条泛解析和www解析是针对国内的,所以执行gitcafe;2条泛解析和www解析是针对国外的,所以指向github.<br>就是添加<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@       <span class="keyword">A</span>      默认  <span class="number">192.30.252.153</span></span><br><span class="line">@       <span class="keyword">A</span>      默认  <span class="number">192.30.252.154</span></span><br><span class="line">@       <span class="keyword">CNAME</span>  国内  gitcafe.io.</span><br><span class="line">www     <span class="keyword">CNAME</span>  默认  jackroyal.github.io.</span><br><span class="line">www     <span class="keyword">CNAME</span>  国内  gitcafe.io.</span><br></pre></td></tr></table></figure></p><p>其他设置项目默认就行了,上面的配置完了,如果你走国外ip访问你的域名的话,会出现404,因为我们还差一步.走国内线路访问一样会出错,都是没绑定的结果.</p><h2 id="4-3-添加github的CNAME文件-添加gitcafe自定义域名"><a href="#4-3-添加github的CNAME文件-添加gitcafe自定义域名" class="headerlink" title="4.3 添加github的CNAME文件,添加gitcafe自定义域名"></a>4.3 添加github的CNAME文件,添加gitcafe自定义域名</h2><p>现在只差最后一步了,我们先来配置github的CNAME文件,官网有个教程<a href="https://help.github.com/articles/adding-a-cname-file-to-your-repository/" target="_blank" rel="noopener">配置CNAME文件</a>.说白了,就是在你的网站根目录,添加一个名为<code>CNAME</code>的文件,里面的内容就是你的域名<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bblove.<span class="keyword">me</span></span><br></pre></td></tr></table></figure></p><p>没有任何多余的信息,如下图<br><img src="https://ww1.sinaimg.cn/large/692869a3gw1eyea41g3amj20uz0a4jtg.jpg" alt="配置github的CNAME"><br>上面的配置现在访问没问题,但是你一重新发布博客,就需要重新手动添加<code>CNAME</code>文件,太麻烦.<br>一劳永逸的方法,在你的<code>hexo</code>目录下的<code>source</code>目录中,新建一个<code>CNAME</code>文件夹,然后他每次在你发布博客的时候,都会在你的网站根目录生成一个<code>CNAME</code>文件.<br><img src="https://ww2.sinaimg.cn/large/692869a3gw1eyea9pgd8cj20ko06ct9v.jpg" alt="添加CNAME的目录结构"><br>现在github的配置彻底结束.</p><p>接下来配置gitcafe:<br>1 我们在gitcafe的项目主页,点击<code>项目设置</code>,如下图(之所以截图,是因为我找半天才看到…)<br><img src="https://ww1.sinaimg.cn/large/692869a3gw1eyeadedmh1j20z508eadm.jpg" alt="gitcafe点击&#39;项目设置&#39;"><br>2 然后我们点击<code>pages服务</code>标签,然后添加自己的域名,这些域名是我们之前在dnspod中设置了解析的<br><img src="https://ww3.sinaimg.cn/large/692869a3gw1eyeaftjlagj20sp0dvn1i.jpg" alt="gitcafe配置自定义域名"></p><p>彻底打完收工了</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>总算写完了,写到这里,我一共写了,141行了,写了个把小时.这次主要参考了下面的几篇文章,都写在友情链接里面了.参考了他们的思路,因为他们的方法里面需要自己单独购买vps或者购买CDN,共同的问题是增加了开销,买vps会导致你每次写博客都需要单独发布一次到vps上太麻烦.我后来在网上看到gitcafe也有<code>gitcafe pages</code>服务,如果用这个来处理的话,一来,不会增加多余的开销,他们都是免费的;二来,由于hexo对于多部署的支持,多部署很简单,一次配置,以后就可以不用理会了.<br>ok,收工</p><h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>1 <a href="http://jerryzou.com/posts/feasibility-of-allowing-baiduSpider-for-Github-Pages/" target="_blank" rel="noopener">解决 Github Pages 禁止百度爬虫的方法与可行性分析</a><br>2 <a href="http://www.dozer.cc/2015/06/github-pages-and-cdn.html" target="_blank" rel="noopener">利用 CDN 解决百度爬虫被 Github Pages 拒绝的问题</a><br>3 <a href="https://help.gitcafe.com/manuals/help/pages-services" target="_blank" rel="noopener">gitcafe官方文档–pages服务</a><br>4 <a href="https://help.gitcafe.com/manuals/help/ssh-key" target="_blank" rel="noopener">gitcafe官方文档–配置ssh公钥</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;update&lt;/em&gt;:因为gitcafe在5月31号就关闭了,所以要将文章中的gitcafe换掉,我重新写了一篇,在这里&lt;a href=&quot;http://jackroyal.github.io/2016/03/06/migrate-pages-from-gitcafe-to-coding/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解决 Github Pages 禁止百度爬虫的方法2–从gitcafe迁移到coding.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近,我的github student package里面送的一个namecheap域名终于下来了.That is to say:我终于有自己的域名了,这就是我的域名&lt;a href=&quot;http://bblove.me&quot;&gt;http://bblove.me&lt;/a&gt;,欢迎来访.&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://bblove.me/categories/hexo/"/>
    
    
      <category term="github" scheme="https://bblove.me/tags/github/"/>
    
      <category term="hexo" scheme="https://bblove.me/tags/hexo/"/>
    
      <category term="baidu" scheme="https://bblove.me/tags/baidu/"/>
    
  </entry>
  
  <entry>
    <title>git使用笔记(2)</title>
    <link href="https://bblove.me/2015/11/04/my-git-note2/"/>
    <id>https://bblove.me/2015/11/04/my-git-note2/</id>
    <published>2015-11-04T08:52:25.000Z</published>
    <updated>2018-05-30T01:57:59.330Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇笔记,只写了些git的基础操作,这篇写一下稍微高阶一点的操作,实际项目的时候可能经常会用到.<br><a id="more"></a></p><h1 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h1><p>撤销操作,我经常会用到,有时候写的代码没有考虑周全,或者有疏漏,需要重新提交什么的.</p><h1 id="1-撤销工作空间最近的修改"><a href="#1-撤销工作空间最近的修改" class="headerlink" title="1 撤销工作空间最近的修改"></a>1 撤销工作空间最近的修改</h1><p>应用场景:比如上次push以后的完整干净的目录,工作空间没有任何修改,暂存区也没有任何修改,如下图:<br><img src="https://ww2.sinaimg.cn/large/692869a3gw1exp9lmtz38j20cl0383yn.jpg" alt="上一次提交后干净的工作目录"><br>这时候,你手贱,改了一下其中的一个文件,但是这次更改是没有意义的.我们继续使用<code>git status</code>来查看<br><img src="https://ww4.sinaimg.cn/large/692869a3gw1exp9ngk82jj20it07i75f.jpg" alt="修改一个文件后执行git status的结果"><br>我们现在想撤销这次修改.<br>解决方法:现在这个修改只是工作区的修改,我们要撤销很简单执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout a.txt</span><br></pre></td></tr></table></figure></p><p>搞定</p><h1 id="2-撤销暂存区最近的修改"><a href="#2-撤销暂存区最近的修改" class="headerlink" title="2 撤销暂存区最近的修改"></a>2 撤销暂存区最近的修改</h1><p>应用场景:假如在上面说的那种情况下,你手贱改错了文件,而且你没有撤销,你还执行<code>git add a.txt</code>,将修改提交到暂存区了.具体情况如下图<br><img src="https://ww2.sinaimg.cn/large/692869a3gw1expa1cbny2j20ge0790td.jpg" alt="错误的修改被提交到了暂存区"><br>现在我们要从暂存区撤回那个修改<br>解决办法:我们使用<code>git reset HEAD a.txt</code>,将文件从暂存区撤出来,又回到上面的工作空间被修改的状态,如图<br><img src="https://ww2.sinaimg.cn/large/692869a3gw1expa3azt15j20hg09twft.jpg" alt="从暂存区撤回"><br>ps:上面的命令也可以用下面的命令,语法格式是<code>git reset &lt;path&gt;</code>,括号中填路径<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset a.txt</span><br></pre></td></tr></table></figure></p><p>总的来说,<code>git reset &lt;path&gt;</code>就是<code>git add &lt;path&gt;</code>的反向操作</p><h1 id="3-撤销提交到本地仓库的修改"><a href="#3-撤销提交到本地仓库的修改" class="headerlink" title="3 撤销提交到本地仓库的修改"></a>3 撤销提交到本地仓库的修改</h1><p>应用场景:假如你在<code>1.2</code>还没有回头,一路手贱下去,将暂存区的修改<code>commit</code>到本地仓库了<br><img src="https://ww4.sinaimg.cn/large/692869a3gw1expa8o47yvj20fi087gmv.jpg" alt="错误的修改被提交到本地仓库"><br>我们现在要从仓库撤销这次没用的提交<br>解决方法:</p><h4 id="1-3-1-方案一-再新建一次提交"><a href="#1-3-1-方案一-再新建一次提交" class="headerlink" title="1.3.1 方案一  再新建一次提交"></a>1.3.1 方案一  再新建一次提交</h4><p>我们可以新建一次提交,然后让所修改的文件回到之前的状态,执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure></p><p>含义很简单,逆转,这样你的<code>log</code>里面会多一次提交,然后文件也回到的之前的状态<br><img src="https://ww4.sinaimg.cn/large/692869a3gw1expb97iondj20it0catb7.jpg" alt="执行git revert 后的log"></p><p>#3.2 方案二  干净的撤销上一次commit<br>上面的方案一对于一个强迫症来说,不能忍啊,本来就是一次错误的提交,为了弥补这个错误,我却还要多提交一次,完全不能忍受.<br>方案二,我们使用<code>git reset</code>命令.我们执行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="keyword">HEAD</span>^</span><br></pre></td></tr></table></figure></p><p>这个命令表示重置HEAD指针,我们要指向上一次提交(也就是取消最近的一次,HEAD表示当前指针,HEAD^是上一次,HEAD^^是上上次,HEAD^^^是上三次),<code>git reset</code>命令可以添加<code>--mixed</code>,<code>--soft</code>,<code>--hard</code>三种参数,<code>--soft</code>程度最轻,只会撤销提交,对当前暂存区和当前工作空间不会有任何更改,默认的参数是<code>--mixed</code>,他会将暂存区的文件撤销<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--soft :取消了commit  </span></span><br><span class="line"></span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--mixed（默认） :取消了commit ，取消了add</span></span><br><span class="line"></span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard :取消了commit ，取消了add，取消源文件修改</span></span><br></pre></td></tr></table></figure></p><h1 id="3-3-方案三-修改最后一次提交"><a href="#3-3-方案三-修改最后一次提交" class="headerlink" title="3.3 方案三  修改最后一次提交"></a>3.3 方案三  修改最后一次提交</h1><p><strong>首先强调,下面说的实在本地仓库的操作.</strong><br>应用场景:对于上面提到的错误的提交,我们还可以修改他的内容,删除我们错误的修改,将它恢复到原来的样子,我们可以使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></p><p>这个方法是将当前暂存区快照提交,也就是你后面的修改合在一起,然后再提交.最后查看<code>log</code>的时候,会只有一次提交,前面的一次提交就被删除,在<code>log</code>中只看到这次提交.<br>用具体例子来说.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"这是第一次提交"</span></span><br><span class="line"><span class="comment">#commit完,我们修改工作空间的内容,然后再执行</span></span><br><span class="line">git add b.txt</span><br><span class="line">git commit --amend</span><br><span class="line"><span class="comment">#这条命令会弹出一个编辑窗口,你可以修改提交信息</span></span><br><span class="line"><span class="comment">#假设我们将提交信息修改为"这是第二次提交"</span></span><br></pre></td></tr></table></figure></p><p>接着当我们使用<code>git log</code>来查看的时候,你只会看到提交信息是”这是第二次提交”.<br>解决方法:<br>我们先将文件内容恢复到上一次(当前是HEAD,上一次就是HEAD^)提交时候的样子,然后执行<code>git commit --amend</code>,看到如下错误提示,就是说这次文件没有任何修改(废话,我已经恢复正确的样子了,当然一模一样了),默认是不允许空提交的,你只有强制使用<code>--allow-empty</code>才行,或者执行方案二<br><img src="https://ww1.sinaimg.cn/large/692869a3gw1expt5luwo4j20io06cq3w.jpg" alt="执行git commit --amend内容没有变化的错误提示"></p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>盗图一张,总结上面说的内容<br><img src="https://ww2.sinaimg.cn/large/692869a3gw1exptkjlw1fj20jg09fq3k.jpg" alt="工作空间,暂存区,本地仓库之间的关机和转换"><br>打完收工</p><h3 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h3><p><strong>PS</strong>:现在再来解释开头说的,这是本地仓库的操作.<br>因为,我们本地仓库执行了<code>git commit</code>后,所做的更改只会在本地,如果接着执行了<code>git push</code>那么,所做的更改就会被提交到<code>git</code>,在上面的例子中那么首先提交到github的就是<code>&quot;这是第一次提交&quot;</code>.这时候,当你执行完<code>git commit --amend</code>的时候,本地仓库的上次提交会被删除,也就是不存在提示信息为<code>&quot;这是第一次提交&quot;</code>,此时本地仓库完成了修改,你想提交到github,就会报错了.如图所示<br><img src="https://ww1.sinaimg.cn/large/692869a3gw1exp93i04qtj20it0cajua.jpg" alt="本地执行--amend操作后直接提交到github报错"><br>解决方法就是,<strong>Force</strong><br>没错,强制提交<code>git push -f</code>,这样他就会像本地一样,删除上一次提交,添加这一次提交</p><h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>1 <a href="https://help.github.com/articles/changing-a-commit-message/" target="_blank" rel="noopener">修改提交信息</a><br>2 <a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="noopener">如何撤销在git上的各种修改,好文</a><br>3 <a href="http://my.oschina.net/MinGKai/blog/144932" target="_blank" rel="noopener">git revert和git reset的区别</a><br>4 <a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">git常用命令介绍,带效果图的</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇笔记,只写了些git的基础操作,这篇写一下稍微高阶一点的操作,实际项目的时候可能经常会用到.&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://bblove.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://bblove.me/tags/Linux/"/>
    
      <category term="github" scheme="https://bblove.me/tags/github/"/>
    
      <category term="git" scheme="https://bblove.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git使用笔记(1)</title>
    <link href="https://bblove.me/2015/11/04/my-git-note1/"/>
    <id>https://bblove.me/2015/11/04/my-git-note1/</id>
    <published>2015-11-04T04:17:04.000Z</published>
    <updated>2018-05-30T01:57:59.314Z</updated>
    
    <content type="html"><![CDATA[<p>git也用了一段时间了,还是写点笔记,记录一下.<br><a id="more"></a></p><h1 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h1><p>首先假装你已经安装好了git</p><ul><li>在Linux下<br>  我用的是<code>ubuntu</code>,安装非常easy,使用<code>sudo apt-get install git</code></li><li>在windows下<br>  在windows下安装,就使用<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git-downloads</a>,点击下载,安装,就ok.<br>ps:如果你足够幸运,可以试试<a href="https://desktop.github.com/" target="_blank" rel="noopener">github的windows版</a>,这个的好处是,带有图形化界面.</li></ul><h1 id="1-初始化git设置"><a href="#1-初始化git设置" class="headerlink" title="1 初始化git设置"></a>1 初始化git设置</h1><p>新装好git后,我们先配置个人的用户名和email,这两条配置很重要,因为在git的日志中,都会带上这两条信息.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"John Doe"</span></span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure></p><p>如果用了<code>--global</code>选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉<code>--global</code>选项重新配置即可，新的设定保存在当前项目的<code>.git/config</code>文件里。</p><h1 id="2-新建第一个仓库"><a href="#2-新建第一个仓库" class="headerlink" title="2 新建第一个仓库"></a>2 新建第一个仓库</h1><p>建立第一个仓库有两种方式,一种是完全新建一个仓库,第二种是克隆一个现有仓库.</p><h4 id="2-1-完全新建一个仓库"><a href="#2-1-完全新建一个仓库" class="headerlink" title="2.1 完全新建一个仓库"></a>2.1 完全新建一个仓库</h4><p>你先切换到你想建项目的地方,比如<code>f:/blog/</code>,然后执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></p><p>初始化后再在当前目录新建一个名为<code>.git</code>的目录,git所有的东西都存在这里面.当然我们不用管.</p><h4 id="2-2-克隆一个现有仓库"><a href="#2-2-克隆一个现有仓库" class="headerlink" title="2.2 克隆一个现有仓库"></a>2.2 克隆一个现有仓库</h4><p>这个也是很easy,直接一条命令搞定<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Jackroyal/blog.git</span><br></pre></td></tr></table></figure></p><p>他会在你的当前目录新建一个<code>blog</code>文件夹,在<code>blog</code>文件夹里面他会把相关的文件都下载下来,就可以用了.</p><h1 id="3-提交更新"><a href="#3-提交更新" class="headerlink" title="3 提交更新"></a>3 提交更新</h1><h4 id="3-1-提交工作空间文件到暂存区"><a href="#3-1-提交工作空间文件到暂存区" class="headerlink" title="3.1 提交工作空间文件到暂存区"></a>3.1 提交工作空间文件到暂存区</h4><p>执行<code>touch a.txt</code>,我们在目录中新建一个文件名叫<code>a.txt</code>,然后我们修改它的内容.<br>接下来,我们来查看下状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></p><p>执行结果如下图:<br><img src="https://ww1.sinaimg.cn/large/692869a3gw1exoxiu5jyij20it0933zl.jpg" alt="执行git status查看工作区文件状态"><br>就像图片中提示的,我们新加的<code>a.txt</code>是未跟踪文件,我们执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add a.txt</span><br></pre></td></tr></table></figure></p><p>我们把<code>a.txt</code>添加到暂存区,再次执行<code>git status</code>,查看状态,执行结果如图所示<br><img src="https://ww2.sinaimg.cn/large/692869a3gw1exoxp6duu1j20it07o0th.jpg" alt="添加到暂存区后再次执行git status"></p><h4 id="3-2-将暂存区文件保存到本地仓库"><a href="#3-2-将暂存区文件保存到本地仓库" class="headerlink" title="3.2 将暂存区文件保存到本地仓库"></a>3.2 将暂存区文件保存到本地仓库</h4><p>假如你要做的修改已经改完,已经保存到暂存区了,我们准备提交到本地仓库.执行<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">"这是提交内容"</span></span><br></pre></td></tr></table></figure></p><p>参数<code>-m</code>,就是添加说明,方便以后查看,你就可以知道自己做了哪些更改</p><h4 id="3-3-将本地仓库内容提交到远程仓库"><a href="#3-3-将本地仓库内容提交到远程仓库" class="headerlink" title="3.3 将本地仓库内容提交到远程仓库"></a>3.3 将本地仓库内容提交到远程仓库</h4><p>上面的步骤都弄好以后,我们提交到远程仓库<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure></p><p>然后就行了,一个基本的流程就是这样.<br>推荐看看下面友情链接里面的那本书,pro git<br><img src="https://ww1.sinaimg.cn/large/692869a3gw1exp17u1ltjj208r0boq38.jpg" alt="pro git封面"></p><h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>1 <a href="http://iissnan.com/progit/" target="_blank" rel="noopener">pro git中文书籍在线版</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git也用了一段时间了,还是写点笔记,记录一下.&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://bblove.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://bblove.me/tags/Linux/"/>
    
      <category term="github" scheme="https://bblove.me/tags/github/"/>
    
      <category term="git" scheme="https://bblove.me/tags/git/"/>
    
  </entry>
  
</feed>
